# I18N

## Example of i18n message

Given an i18n component:
```typescript
@Component({
  template: `
    <div i18n-title="Hello {{name}}!" i18n>
      {{count}} is rendered as:  
      <b *ngIf="exp">
        { count, plural, 
            =0 {no <b title="none">emails</b>!} 
            =1 {one <i>email</i>} 
            other {{{count}} <span title="{{count}}">emails</span>}
        }
      </b>.
    </div>
  `
})
class MyComponent {
}
```
NOTE:
- There really is only two kinds of i18n text.
  1. In attributes `i18n-title`.
  2. In element body marked as `<div i18n>`.
- The element body i18n can have internal DOM structure which may consist of sub-templates.


The compiler generates:
```typescript
const MSG_title = goog.getMsg('Hello {ph_0}!');
const MSG_MAP_title = ['ph_0'];
const MSG_div = goog.getMsg('{ph_1} is rendered as: {START_0}{$icu0}{END_0}.', {
  icu0: `{count, plural, 
              =0 {no <b title="none">emails</b>!} 
              =1 {one <i>email</i>} 
              other {{{count}} <span title="{{count}}">emails</span>}
          }`
});
const MSG_MAP_div = [
  'ph_1', 
  [3, 'START_0', 'END_0', 'count']
];

function MyComponent_NgIf_Template_0(rf: RenderFlags, ctx: any) {
  if (rf & RenderFlags.Create) {
    i18nStart(0, MSG_div, MSG_MAP_div, 1);
      element(1, 'b');
    i18nEnd();
  }
  if (rf & RenderFlags.Update) {
    i18nExp(bind(ctx.count));
    i18nApply(0);
  }
}

class MyComponent {
  static ngComponentDef = defineComponent({
    ...,
    template: function(rf: RenderFlags, ctx: MyComponent) {
      if (rf & RenderFlags.Create) {
        elementStart(0, 'div');
          i18nParseInterpolation(1, MSG_title, MSG_MAP_title);
          i18nStart(2, MSG_div, MSG_MAP_div);
            template(3, MyComponent_NgIf_Template_0, ...);
          i18nEnd();
        elementEnd();
      }
      if (rf & RenderFlags.Update) {
        elementProperty(0, 'title', i18nInterpolation1(1, myApp.count));
      }
    }
  });  
}
```

REQUIREMENTS:
- Must preserve DOM structure in i18n blocks because those DOM structures may have components and directives.
- The parsed instructions must stay in `TView.data`. 
  This is because in case of SSR we need to be able to execute multiple locales in the same VM.
  (If instructions would be at a top level we could not have more than one parsed instruction.)
  The plan is to cache `TView.data` per locale, hence different instructions would get cached into different `TView.data` associated with a given locale.
  - NOTE: in SSR `goog.getMsg` will return an object literal of all of the locale translations.

## 18n Attributes

Let's look at the simpler case of i18n and attribute interpolation.

```typescript
// This line extracts localized string.
const MSG_title = goog.getMsg('Hello {ph_0}!');
// This line defines mapping locations from the expressions to positions in the interpolation
const MSG_MAP_title = [
  'ph_0', // The expression at position `0` will be mapped to `ph_0`
];
```
Next notice the `i18nParseInterpolation` instruction inside the `RenderFlags.Create` block.

```typescript
i18nParseInterpolation(1, MSG_title, MSG_MAP_title);
```
The above instruction checks the `TView.data` cache at position `1` and if empty will create instructions like so:
```typescript
[
  'Hello ',
  0,         // Insert value of expression at position 0.
  '!'
]
```

Then the `i18nInterpolation1` instruction generates the rendered text as follows:
```typescript
elementAttribute(
  0,                    // reference to <div> 
  'title',              // refer to the `title` attribute
  i18nInterpolation1(
    1,                  // refer to the concatenation instructions from `i18nParseInterpolation` see above.
    myApp.count         // expression at `0` position.
  )
);
```

The `i18nInterpolation1` instruction concatenates the i18n message and than uses `elementAttribute` instruction to assign it to the DOM.

## i18n Elements

Generating text inside existing elements is a bit more complicated but follows the same philosophy as attributes.

First we define the message and mapping (which placeholders map to which expressions) as so:

```typescript
const MSG_div = goog.getMsg('{ph_1} is rendered as: {START_0}{$icu0}{END_0}.', {
  icu0: `{count, plural, 
              =0 {no <b title="none">emails</b>!} 
              =1 {one <i>email</i>} 
              other {{{count}} <span title="{{count}}">emails</span>}
          }`
});
const MSG_MAP_div = [
  'ph_1',       // For the top level translation placeholder `ph_1` use expression at position `0`.
  [             // Exclusion zones for sub-templates.
    3,          // At position `3` there is a sub template. 
                //   See: `template(3, MyComponent_NgIf_Template_0, ...)`
    'START_0',  // The sub template starts at `START_0`
    'END_0',    // The sub template ends at `END_0`
                //   Everything in front of `START_0` is in front of position `3` (`template(3, ...)`)
                //   Everything after `END_0` is after position `3` (`template(3, ...)`)
    'count'     // For the sub-template translation placeholder `count` use expression at position `0`.
                //   `count` is at position `3` but we subtract `-3` (for `3`, `START_0`, and `END_0`) so it is `0`.
  ]
];
```

Most 18n translations do not have sub-templates and therefor the map is just a single array.
For the rare case where a translation has a sub-template the sub-array describes an exclusion zone defined by start/end marker.
The exclusion zone is removed from the translation so in our case it is as if we had two separate translations for parent and sub-template.
(See a more complicated case later.)

The exclusion zones split the messages up. It as as if we had this code (not actual generated code.)
```typescript
// Message and mapping for root template
const MSG_div = goog.getMsg('{ph_1} is rendered as: {ph_sub_template_3}.');
const MSG_MAP_div = ['ph_1'];

// Message and mapping for sub-template
const MSG_div_sub_template_3 = goog.getMsg('{$icu0}', {
  icu0: `<b>{count, plural, 
              =0 {no <b title="none">emails</b>!} 
              =1 {one <i>email</i>} 
              other {{{count}} <span title="{{count}}">emails</span>}
          }</b>`
});
const MSG_MAP_div_sub_template_3 = ['count'];
```
We can than process the above two translations as two independent translations.

### `i18nStart`

It is a job of `i18nStart` instruction to parse the messages and to fill in the translation blocks with text.
(Notice that in 18n block the DOM element instructions are retained, but the text instructions have been stripped.)

```typescript
i18nStart(
    2,           // storage of the parsed message instructions
    MSG_div,     // The massage to parse which has bee translated
    MSG_MAP_div, // Mapping information from translated text place holders to expressions.
                 // Optional sub-template index. Empty implies `0` (most common)
);
...
i18nEnd();       // The instruction which is responsible for inserting text nodes into the render tree based on translation.
```

The `i18nStart` generates these instructions which are cached in the `TView`.

```typescript
{
  vars: 2,                               // Number of slots to allocate in EXPANDO. 
                                         // Assume in this example EXPANDO starts at 100
  create: <I18nMutateOpCodes>[
    // Insert empty text node (will be filled later with interpolation) in front of `ngIf` anchor (index 3).
    "", 3 << I18nMutateOpCodes.SHIFT_PARENT | I18nMutateOpCodes.InsertBefore // assume EXPANDO position 100
    // Insert `"."` text node after `ngIf` anchor. (Append to ngIf parent `<div>`);
    ".", 0 << SHIFT_PARENT | AppendChild                                     // assume EXPANDO position 101
  ],
  update: <I18nUpdateOpCodes>[
    // Header which consist of change mask and block size.
    // If `changeMask & 0b1`
    //        has changed than execute update OpCodes.
    //        has NOT change than skip `3` values and start processing next OpCodes.
    0b1, 3,
    // Concatenate: `newValue = lViewData[bindIndex-1] + 'is rendered as: ';
    -1, 'is rendered as: ',
    // Flush the concatenated string to text node at position 100. 
    100 << SHIFT_REF | Text,
  ],
  icus: null,
}
```

### `i18nStart` in sub-template

```typescript
i18nStart(
    0,           // storage of the parsed message instructions
    MSG_div,     // The massage to parse which has bee translated
    MSG_MAP_div, // Mapping information from translated text place holders to expressions.
    1            // Optional sub-template index.
);
```

Notice that in sub-template the `i18nStart` instruction takes offset of `1` as the last argument.
This means that the instruction has to extract out its sub-type from the root-template translation.

Starting with
```typescript
const MSG_div = goog.getMsg('{ph_1} is rendered as: {START_0}{$icu0}{END_0}.', {
  icu0: `{count, plural, 
              =0 {no <b title="none">emails</b>!} 
              =1 {one <i>email</i>} 
              other {{{count}} <span title="{{count}}">emails</span>}
          }`
});
const MSG_MAP_div = [
  'ph_1', 
  [3, 'START_0', 'END_0', 'count']
];
```

The `i18nStart` instruction traverses `MSG_MAP_div` and looks for `1`st sub-template.
In this case we extract `[3, 'START_0', 'END_0', 'count']` because it is `1`st.
We then strip the sub-template header to get `['count']`.
Notice that the header contains index to the DOM element `3` and placeholders which designate start/end (`START_0`/`END_0`).
The rest of code should work same as described above.

This case is more complex because it contains an ICU.
ICUs are pre-parsed and than stored in tho th TVIEW.data as follows.

```typescript
<TI18n>{
  vars: 5,                               // Number of slots to allocate in EXPANDO. 
                                         // Assume in this example EXPANDO starts at 200
  create: <I18nMutateOpCodes>[
    // Equivalent to:
    //   const node = lViewData[index++] = document.createComment('');
    //   lViewData[0].appendChild(node);
    null, 0 << SHIFT_PARENT | AppendChild,
  ],
  update: <I18nUpdateOpCodes>[
    // The following OpCodes represent: `<b>{count, plural, ... }</b>">`
    // If `changeMask & 0b1`
    //        has changed than execute update OpCodes.
    //        has NOT change then skip `4` values and start processing next OpCodes.
    0b1, 4,
    // Concatenate `newValue = lViewData[bindIndex -1];`.
    -1,
    // Switch ICU: `icuSwitchCase(lViewData[0], 0, newValue);`
    0 << SHIFT_ICU | 0 << SHIFT_REF | IcuSwitch,
 
    // Note `changeMask & -1` is always true, so the IcuUpdate will always execute.
    -1, 1,
    // Update ICU: `icuUpdateCase(lViewData[0], 0);`
    0 << SHIFT_ICU | 0 << SHIFT_REF | IcuUpdate,

  ],
  icus: [
    <TIcu>{
      cases: [0, 1, 'other'],
      create: [
        // Case: `0`
        <I18nMutateOpCodes>[

        ]
        // Case: `1`
        <I18nMutateOpCodes>[

        ]
        // Case: `"other"`
        <I18nMutateOpCodes>[

        ]
      ],
      remove: [
        // Case: `0`
        <I18nMutateOpCodes>[

        ]
        // Case: `1`
        <I18nMutateOpCodes>[

        ]
        // Case: `"other"`
        <I18nMutateOpCodes>[

        ]
      ],
      update: [
        // Case: `0`
        <I18nUpdateOpCodes>[

        ]
        // Case: `1`
        <I18nUpdateOpCodes>[

        ]
        // Case: `"other"`
        <I18nUpdateOpCodes>[

        ]
      ]
    }
  ]
}
```


TODO:
- computing the expando positions? It is just current binding position - some index
- List all of the instructions.
- explain how ICUs will parse the DOM templates.
- Deeply nested exclusions such as `<div i18n><span *ngFor><b *ngIf></b></span><tt *ngIf></tt>`
- Multiple placeholders per expression.