# I18N

## Example of i18n message

Given an i18n component:
```typescript
@Component({
  template: `
    <div i18n-title="Hello {{name}}!">
      {{count}} is rendered as:  
      <b *ngIf="exp">
        { count, plural, 
            =0 {no <b>emails</b>} 
            =1 {one <i>email</i>} 
            other {{{count}} <span title="{{count}}">emails</span>}
        }
      </b>.
    </div>
  `
})
class MyComponent {
}
```
NOTE:
- There really is only two kinds of i18n text.
  1. In attributes `i18n-title`.
  2. In element body marked as `<div i18n>`.
- The element body i18n can have internal DOM structure which may consist of sub-templates.


The compiler generates:
```typescript
const MSG_title = goog.getMsg('Hello {ph_0}!');
const MSG_MAP_title = ['ph_0'];
const MSG_div = goog.getMsg('{ph_0} is rendered as: {START_0}{$icu0}{END_0}.', {
  icu0: `{count, plural, 
              =0 {no <b>emails</b>} 
              =1 {one <i>email</i>} 
              other {{{count}} <span title="{{count}}">emails</span>}
          }`
});
const MSG_MAP_div = [
  'ph_0', 
  [3, 'START_0', 'END_0', 'count']
];

function MyComponent_NgIf_Template_0(rf: RenderFlags, ctx: any) {
  if (rf & RenderFlags.Create) {
    i18nStart(0, MSG_div, MSG_MAP_div, 0);
      element(1, 'b');
    i18nEnd();
  }
  if (rf & RenderFlags.Update) {
    i18nExp(bind(ctx.count));
    i18nApply(0);
  }
}

class MyComponent {
  static ngComponentDef = defineComponent({
    ...,
    template: function(rf: RenderFlags, ctx: MyComponent) {
      if (rf & RenderFlags.Create) {
        elementStart(0, 'div');
          i18nMsg(1, MSG_title, MSG_MAP_title);
          i18nStart(2, MSG_div, MSG_MAP_div);
            template(3, MyComponent_NgIf_Template_0, ...);
          i18nEnd();
        elementEnd();
      }
      if (rf & RenderFlags.Update) {
        elementProperty(0, 'title', i18nInterpolation1(1, myApp.count));
      }
    }
  });  
}
```

REQUIREMENTS:
- Must preserve DOM structure in i18n blocks because those DOM structures may have components and directives. 
- The parsed instructions must stay in `TView`. 
  This is because in case of SSR we need to be able to execute multiple locales in the same VM.
  (If instructions would be at a top level we could not have more than one parsed instruction.)
  The plan is to cache `TView` per locale, hence different instructions would get cached into different `TView` associated with a given locale.
  - NOTE: in SSR `goog.getMsg` will return an object literal of all of the locale translations.

## 18n Attributes

Let's look at the simpler case of i18n and attribute interpolation. 

```typescript
// This line extracts localized string.
const MSG_title = goog.getMsg('Hello {ph_0}!');
// This line defines mapping locations from the expressions to positions in the interpolation
const MSG_MAP_title = [
  'ph_0', // The expression at position `0` will be mapped to `ph_0`
];
```
Next notice the `i18nMsg` instruction inside the `RenderFlags.Create` block.

```typescript
i18nMsg(1, MSG_title, MSG_MAP_title);
```

The above instruction checks the `TView` cache at position `1` and if empty will create instructions like so:
```typescript
[
  'Hello ',
  0,         // Insert value of expression at position 0.
  '!'
]
```

Then the `i18nInterpolation1` instruction generates the rendered text as follows:
```typescript
elementAttribute(
  0,                    // reference to <div> 
  'title',              // refer to the `title` attribute
  i18nInterpolation1(
    1,                  // refer to the concatenation instructions from `i18nMsg` see above.
    myApp.count         // expression at `0` position.
  )
);
```

The above instruction concatenates the i18n message and than uses `elementAttribute` instruction to assign it.

## i18n Elements

Generating text inside existing elements is a bit more complicated but follows the same philosophy as attributes. 

First we define the message and mapping as so:

```typescript
const MSG_div = goog.getMsg('{ph_0} is rendered as: {START_0}{$icu0}{END_0}.', {
  icu0: `{count, plural, 
              =0 {no <b>emails</b>} 
              =1 {one <i>email</i>} 
              other {{{count}} <span title="{{count}}">emails</span>}
          }`
});
const MSG_MAP_div = [
  'ph_0',       // For the top level translation use expression at `0` position for `ph_0`.
  [             // Exclusion zones for sub-templates.
    3,          // At position `3` there is a sub template. See: `template(3, MyComponent_NgIf_Template_0, ...)`
    'START_0',  // The sub template starts at `START_0`
    'END_0',    // The sub template ends at `END_0`
    'count'     // For the top sub-template translation use expression at `0` position for `count`.
  ]
];
```

Most 18n translations do not have sub-templates and therefor the map is just a single array.
For the rare case where a translation has a sub-template the sub-array describes an exclusion zone defined by start/end marker.
The exclusion zone is removed from the translation so in our case it is as if we had two separate translations for parent and sub-template.

```typescript
const MSG_div = goog.getMsg('{ph_0} is rendered as: {ph_sub_template_3}.');
const MSG_MAP_div = ['ph_0'];

const MSG_div_sub_template_3 = goog.getMsg('{$icu0}', {
  icu0: `{count, plural, 
              =0 {no <b>emails</b>} 
              =1 {one <i>email</i>} 
              other {{{count}} <span title="{{count}}">emails</span>}
          }`
});
const MSG_MAP_div_sub_template_3 = ['count'];
```
We can than process the above two translations as two independent translations. 

### `i18nStart`

It is a job of `i18nStart` instruction to parse the messages and to fill in the translation blocks with text.
(Notice that in 18n block the DOM element instructions are retained, but the text instructions have been stripped.)

```typescript
i18nStart(
    2,           // storage of the parsed message instructions
    MSG_div,     // The massage to parse which has bee translated
    MSG_MAP_div, // Mapping information from translated text place holders to expressions.
                 // Optional sub-template index. Empty implies `0` (most common)
);
...
i18nEnd();       // The instruction which is responsible for inserting text nodes into the render tree based on translation.
```

The `i18nStart` generates these instructions which are cached in the `TView`.

```typescript
{
  create: [
      3 | I18nInstructions.Select,       // Select element at position 3 (ngIf)
      I18nInstructions.InsertBeforeText, // Insert a child text node ...
      "",                                //                          ... which will be filled with interpolation.
                                         // Assume stored at EXPANDO position 123
      I18nInstructions.AppendChildText,  // Append a child text node ...
      ".",                               //                          ... with the following text.
                                         // Assume stored at EXPANDO position 124
  ],
  update: [
    0,                                   // insert value of expression at position 0
    'is rendered as: ',                  // append the text
    -123,                                // Flush the concatenated string to text node at position 123. 
  ]
}
```

Questions:
- computing the expando positions?


TODO:
- explain how ICUs will parse the DOM templates. 