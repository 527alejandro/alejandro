/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

import * as fs from 'fs';
import * as path from 'path';
import * as shx from 'shelljs';


function main(args: string[]): number {
  // Exit immediately when encountering an error.
  shx.set('-e');

  // This utility expects all of its arguments to be specified in a params file generated by
  // bazel (see https://docs.bazel.build/versions/master/skylark/lib/Args.html#use_param_file).
  const paramFilePath = args[0];

  // Paramaters are specified in the file one per line. Empty params are represented as two
  // single-quotes, so turn these into real empty strings..
  const params = fs.readFileSync(paramFilePath, 'utf-8').split('\n').map(s => s === "''" ? '' : s);

  // The parameters are in a fixed order.
  const [
    // Output directory for the npm package.
    out,

    // The package segment of the ng_package rule's label (e.g. 'package/common').
    srcDir,

    // The bazel-bin dir joined with the srcDir (e.g. 'bazel-bin/package.common').
    // This is the intended output location for package artifacts.
    binDir,

    // Path to the package's README.md
    readmeMd,

    // List of flattenned, ES2015 files generated by rollup ???
    fesms2015Arg,

    // List of flattenned, ES5 files generated by rollup ???
    fesms5Arg,

    // List of all UMD bundles generated by rollup ???
    bundlesArg,

    // List of all files in the ng_package rule's srcs.
    srcsArg,
    stampData,

    // Path to the package's LICENSE.
    licenseFile
  ] = params;

  const fesms2015 = fesms2015Arg.split(',').filter(s => !!s);
  const fesms5 = fesms5Arg.split(',').filter(s => !!s);
  const bundles = bundlesArg.split(',').filter(s => !!s);
  const srcs = srcsArg.split(',').filter(s => !!s);

  shx.mkdir('-p', out);

  let primaryEntryPoint: string|null = null;
  const secondaryEntryPoints = new Set<string>();

  if (readmeMd) {
    shx.cp(readmeMd, path.join(out, 'README.md'));
  }

  fesms2015.forEach(fesm2015 => writeFesm(fesm2015, path.join(out, 'esm2015')));
  fesms5.forEach(fesm5 => writeFesm(fesm5, path.join(out, 'esm5')));

  const bundlesDir = path.join(out, 'bundles');
  shx.mkdir('-p', bundlesDir);
  bundles.forEach(bundle => { shx.cp(bundle, bundlesDir); });

  const allsrcs = shx.find('-R', binDir);
  allsrcs.filter(hasFileExtension('.d.ts')).forEach((f: string) => {
    // Strip the named AMD module for compatibility with non-bazel users
    const content = fs.readFileSync(f, 'utf-8').replace(/^\/\/\/ <amd-module name=.*\/>\n/, '');

    let outputPath: string;
    if (f.endsWith('.bundle_index.d.ts')) {
      outputPath = moveBundleIndex(f);
    } else {
      outputPath = path.join(out, path.relative(binDir, f));
    }
    shx.mkdir('-p', path.dirname(outputPath));
    fs.writeFileSync(outputPath, content);
  });

  let rootPackageName = '';

  // Modify source files as necessary for publishing, including updating the
  // version placeholders and the paths in any package.json files.
  for (const src of srcs) {
    let content = fs.readFileSync(src, 'utf-8');
    content = replaceVersionPlaceholders(content);
    if (path.basename(src) === 'package.json') {
      const packageJson = JSON.parse(content);
      content = amendPackageJson(packageJson);

      // Keep track of the root package name, e.g. "@angular/common". We assume that the
      // root name will be shortest because secondary entry-points will append to it
      // (e.g. "@angular/common/http").
      if (!rootPackageName || packageJson['name'].length < rootPackageName.length) {
        rootPackageName = packageJson['name'];
      }
    }
    const outputPath = path.join(out, path.relative(srcDir, src));
    shx.mkdir('-p', path.dirname(outputPath));
    fs.writeFileSync(outputPath, content);
  }

  allsrcs.filter(hasFileExtension('.bundle_index.metadata.json')).forEach((f: string) => {
    fs.writeFileSync(
        moveBundleIndex(f), replaceVersionPlaceholders(fs.readFileSync(f, 'utf-8')));
  });

  const licenseBanner = licenseFile ? fs.readFileSync(licenseFile, 'utf-8') : '';

  // Generate extra files for secondary entry-points.
  for (const secondaryEntryPoint of secondaryEntryPoints.values()) {
    const entryPointName = secondaryEntryPoint.split('/').pop();
    const entryPointPackageName = `${rootPackageName}/${secondaryEntryPoint}`;

    const dirName = path.join(...secondaryEntryPoint.split('/').slice(0, -1));
    const destDir = path.join(out, dirName);

    createMetadataReexportFile(destDir, entryPointName);
    createTypingsReexportFile(destDir, entryPointName, licenseBanner);
    createEntryPointPackageJson(path.join(destDir, entryPointName), entryPointPackageName);
  }

  return 0;

  // Define functions inside `main` so that they have accessed to the parsed arguments
  // from bazel.

  function replaceVersionPlaceholders(content: string) {
    if (stampData) {
      const version = shx.grep('BUILD_SCM_VERSION', stampData).split(' ')[1].trim();
      // Split the replacement into separate strings so we don't match it while publishing
      return content.replace(
          new RegExp(
              '0.0.0' +
                  '-PLACEHOLDER',
              'g'),
          version);
    }
    return content;
  }

  /**
   * Inserts properties into the package.json file(s) in the package so that
   * they point to all the right generated artifacts.
   *
   * @param parsedPackage Parsed package.json content
   */
  function amendPackageJson(parsedPackage: object) {
    const packageName = parsedPackage['name'];
    const nameParts = getPackageNameParts(packageName);
    const relativePathToPackageRoot = getRelativePathToPackageRoot(packageName);
    const indexFile = nameParts[nameParts.length - 1];

    parsedPackage['main'] = `${relativePathToPackageRoot}/bundles/${nameParts.join('-')}.umd.js`;
    parsedPackage['module'] = `${relativePathToPackageRoot}/esm5/${indexFile}.js`;
    parsedPackage['es2015'] = `${relativePathToPackageRoot}/esm2015/${indexFile}.js`;
    parsedPackage['typings'] = `./${indexFile}.d.ts`;
    return JSON.stringify(parsedPackage, null, 2);
  }

  function writeFesm(file: string, baseDir: string) {
    const parts = path.basename(file).split('__');
    const entryPointName = parts.join('/').replace(/\..*/, '');
    if (primaryEntryPoint === null || primaryEntryPoint === entryPointName) {
      primaryEntryPoint = entryPointName;
    } else {
      secondaryEntryPoints.add(entryPointName);
    }
    const filename = parts.splice(-1)[0];
    const dir = path.join(baseDir, ...parts);
    shx.mkdir('-p', dir);
    shx.cp(file, dir);
    shx.mv(path.join(dir, path.basename(file)), path.join(dir, filename));
  }

  function moveBundleIndex(f: string) {
    let ext: string;

    if (f.endsWith('.d.ts'))
      ext = '.d.ts';
    else if (f.endsWith('.metadata.json'))
      ext = '.metadata.json';
    else
      throw new Error('Bundle index files should be .d.ts or .metadata.json');

    const relative = path.relative(binDir, f);
    let outputPath: string|undefined = undefined;
    for (const secondary of secondaryEntryPoints.values()) {
      if (relative.startsWith(secondary)) {
        const filename = secondary.split('/').pop();
        outputPath = path.join(out, secondary, filename + ext);
      }
    }
    if (!outputPath) {
      outputPath = path.join(out, primaryEntryPoint + ext);
    }
    return outputPath;
  }
}


/** Gets a predicate function to filter non-generated files with a specified extension. */
function hasFileExtension(ext: string): (path: string) => boolean {
  return f => f.endsWith(ext) && !f.endsWith(`.ngfactory${ext}`) && !f.endsWith(`.ngsummary${ext}`);
}

/** Gets a package name split into parts, omitting the scope if present. */
function getPackageNameParts(fullPackageName: string): string[] {
  const parts = fullPackageName.split('/');
  return fullPackageName.startsWith('@') ? parts.splice(1) : parts;
}

/** Gets the relative path to the package root from a given entry-point import path. */
function getRelativePathToPackageRoot(entryPointPath: string) {
  const parts = getPackageNameParts(entryPointPath);
  const relativePath = Array(parts.length - 1).fill('..').join('/');
  return relativePath || '.';
}

/** Creates metadata re-export file for a secondary entry-point. */
function createMetadataReexportFile(destDir: string, entryPointName: string) {
    fs.writeFileSync(path.join(destDir, `${entryPointName}.metadata.json`), JSON.stringify({
    '__symbolic': 'module',
    'version': 3,
    'metadata': {},
    'exports': [{'from': `./${entryPointName}/${entryPointName}`}],
    'flatModuleIndexRedirect': true
  }) + '\n');
}

/**
 * Creates a typings (d.ts) re-export file for a secondary-entry point,
 * e.g., `export * from './common/common'`
 */
function createTypingsReexportFile(destDir: string, entryPointName: string, license: string) {
  // Format carefully to match existing build.sh output:
  // LICENSE SPACE NEWLINE SPACE EXPORT NEWLINE
  const content = `${license} \n export * from \'./${entryPointName}/${entryPointName}\n`;
  fs.writeFileSync(path.join(destDir, `${entryPointName}.d.ts`), content);
}

/**
 * Creates a package.json for a secondary entry-point.
 * @param {string} destDir Directory into which the package.json will be written.
 * @param {string} entryPointPackageName The full package name for the entry point,
 *     e.g. '@angular/common/http'.
 */
function createEntryPointPackageJson(destDir: string, entryPointPackageName: string) {
  const packageNameParts = getPackageNameParts(entryPointPackageName);
  const relativePathToPackageRoot = getRelativePathToPackageRoot(entryPointPackageName);
  const entryPointName = packageNameParts.slice(-1)[0];

  const content = {
    name: `${entryPointPackageName}`,
    typings: `./${entryPointName}.d.ts`,
    main: `${relativePathToPackageRoot}/bundles/${packageNameParts.join('-')}.umd.js`,
    module: `${relativePathToPackageRoot}/esm5/${entryPointName}.es5.js`,
    es2015: `${relativePathToPackageRoot}/esm2015/${entryPointName}.js`,
  };

  fs.writeFileSync(path.join(destDir, 'package.json'), JSON.stringify(content, null, 2), 'utf-8');
}

if (require.main === module) {
  process.exitCode = main(process.argv.slice(2));
}
