/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 *
 * @fileoverview Schematics for ng-new project that builds with Bazel.
 */

import {SchematicContext, apply, applyTemplates, chain, externalSchematic, MergeStrategy, mergeWith, move, Rule, schematic, Tree, url, SchematicsException, UpdateRecorder,} from '@angular-devkit/schematics';
import {parseJsonAst, JsonAstObject, strings, JsonValue} from '@angular-devkit/core';
import {findPropertyInAstObject, insertPropertyInAstObjectInOrder} from '@schematics/angular/utility/json-utils';
import {isJsonAstObject, replacePropertyInAstObject} from '../utility/json-utils';
import {validateProjectName} from '@schematics/angular/utility/validation';
import {getWorkspace} from '@schematics/angular/utility/config';
import {Schema} from './schema';

/**
 * Packages that build under Bazel require additional dev dependencies. This
 * function adds those dependencies to "devDependencies" section in
 * package.json.
 */
function addDevDependenciesToPackageJson(options: Schema) {
  return (host: Tree) => {
    const packageJson = `${options.name}/package.json`;

    if (!host.exists(packageJson)) {
      throw new Error(`Could not find ${packageJson}`);
    }
    const packageJsonContent = host.read(packageJson);
    if (!packageJsonContent) {
      throw new Error('Failed to read package.json content');
    }
    const jsonAst = parseJsonAst(packageJsonContent.toString()) as JsonAstObject;
    const deps = findPropertyInAstObject(jsonAst, 'dependencies') as JsonAstObject;
    const devDeps = findPropertyInAstObject(jsonAst, 'devDependencies') as JsonAstObject;

    const angularCoreNode = findPropertyInAstObject(deps, '@angular/core');
    const angularCoreVersion = angularCoreNode !.value as string;

    const devDependencies: {[k: string]: string} = {
      '@angular/bazel': angularCoreVersion,
      // TODO(kyliau): Consider moving this to latest-versions.ts
      '@bazel/bazel': '^0.23.0',
      '@bazel/ibazel': '^0.9.0',
      '@bazel/jasmine': '^0.26.0',
      '@bazel/karma': '^0.26.0',
      '@bazel/typescript': '^0.26.0',
    };

    const recorder = host.beginUpdate(packageJson);
    for (const packageName of Object.keys(devDependencies)) {
      const version = devDependencies[packageName];
      const indent = 4;
      insertPropertyInAstObjectInOrder(recorder, devDeps, packageName, version, indent);
    }
    host.commitUpdate(recorder);
    return host;
  };
}

/**
 * Append main.dev.ts and main.prod.ts to src directory. These files are needed
 * by Bazel for devserver and prodserver, respectively. They are different from
 * main.ts generated by CLI because they use platformBrowser (AOT) instead of
 * platformBrowserDynamic (JIT).
 */
function addDevAndProdMainForAot(options: Schema) {
  return (host: Tree) => {
    let newProjectRoot = '';
    try {
      const workspace = getWorkspace(host);
      newProjectRoot = workspace.newProjectRoot || '';
    } catch {
    }
    const srcDir = `${newProjectRoot}/${options.name}/src`;

    return mergeWith(apply(url('./files'), [
      applyTemplates({
        utils: strings,
        ...options,
        'dot': '.',
      }),
      move(srcDir),
    ]));
  };
}

function overwriteGitignore(options: Schema) {
  return (host: Tree) => {
    const gitignore = `${options.name}/.gitignore`;
    if (!host.exists(gitignore)) {
      return host;
    }
    const gitIgnoreContent = host.read(gitignore);
    if (!gitIgnoreContent) {
      throw new Error('Failed to read .gitignore content');
    }

    if (gitIgnoreContent.includes('/bazel-out\n')) {
      return host;
    }
    const lines = gitIgnoreContent.toString().split(/\n/g);
    const recorder = host.beginUpdate(gitignore);
    const compileOutput = lines.findIndex((line: string) => line === '# compiled output');
    recorder.insertRight(compileOutput, '\n/bazel-out');
    host.commitUpdate(recorder);

    return host;
  };
}

function updateWorkspaceFileToUseBazelBuilder(options: Schema): Rule {
  return (host: Tree, context: SchematicContext) => {
    const {name} = options;
    const workspacePath = `${name}/angular.json`;
    if (!host.exists(workspacePath)) {
      throw new SchematicsException(`Workspace file ${workspacePath} not found.`);
    }
    const workspaceBuffer = host.read(workspacePath) !;
    const workspaceJsonAst = parseJsonAst(workspaceBuffer.toString()) as JsonAstObject;
    const projects = findPropertyInAstObject(workspaceJsonAst, 'projects');
    if (!projects) {
      throw new SchematicsException('Expect projects in angular.json to be an Object');
    }
    const project = findPropertyInAstObject(projects as JsonAstObject, name);
    if (!project) {
      throw new SchematicsException(`Expected projects to contain ${name}`);
    }
    const recorder = host.beginUpdate(workspacePath);
    const indent = 6;
    replacePropertyInAstObject(
        recorder, project as JsonAstObject, 'architect', {
          'build': {
            'builder': '@angular/bazel:build',
            'options': {'targetLabel': '//src:bundle.js', 'bazelCommand': 'build'},
            'configurations': {'production': {'targetLabel': '//src:bundle'}}
          },
          'serve': {
            'builder': '@angular/bazel:build',
            'options': {'targetLabel': '//src:devserver', 'bazelCommand': 'run'},
            'configurations': {'production': {'targetLabel': '//src:prodserver'}}
          },
          'extract-i18n': {
            'builder': '@angular-devkit/build-angular:extract-i18n',
            'options': {'browserTarget': `${name}:build`}
          },
          'test': {
            'builder': '@angular/bazel:build',
            'options': {'bazelCommand': 'test', 'targetLabel': '//src/...'}
          },
          'lint': {
            'builder': '@angular-devkit/build-angular:tslint',
            'options': {
              'tsConfig': ['src/tsconfig.app.json', 'src/tsconfig.spec.json'],
              'exclude': ['**/node_modules/**']
            }
          }
        },
        indent);

    const e2e = `${options.name}-e2e`;
    const e2eNode = findPropertyInAstObject(projects as JsonAstObject, e2e);
    if (e2eNode) {
      replacePropertyInAstObject(
          recorder, e2eNode as JsonAstObject, 'architect', {
            'e2e': {
              'builder': '@angular/bazel:build',
              'options': {'bazelCommand': 'test', 'targetLabel': '//e2e:devserver_test'},
              'configurations': {'production': {'targetLabel': '//e2e:prodserver_test'}}
            },
            'lint': {
              'builder': '@angular-devkit/build-angular:tslint',
              'options': {'tsConfig': 'e2e/tsconfig.e2e.json', 'exclude': ['**/node_modules/**']}
            }
          },
          indent);
    }

    host.commitUpdate(recorder);
    return host;
  };
}

/**
 * @angular/bazel requires minimum version of rxjs to be 6.4.0. This function
 * upgrades the version of rxjs in package.json if necessary.
 */
function upgradeRxjs(options: Schema) {
  return (host: Tree, context: SchematicContext) => {
    const packageJson = `${options.name}/package.json`;
    if (!host.exists(packageJson)) {
      throw new Error(`Could not find ${packageJson}`);
    }
    const content = host.read(packageJson).toString();
    const jsonAst = parseJsonAst(content);
    if (!isJsonAstObject(jsonAst)) {
      throw new Error(`Failed to parse JSON for ${packageJson}`);
    }
    const deps = findPropertyInAstObject(jsonAst, 'dependencies');
    if (!isJsonAstObject(deps)) {
      throw new Error(`Failed to find dependencies in ${packageJson}`);
    }
    const rxjs = findPropertyInAstObject(deps, 'rxjs');
    if (!rxjs) {
      throw new Error(`Failed to find rxjs in dependencies of ${packageJson}`);
    }
    const value = rxjs.value as string;  // value can be version or range
    const match = value.match(/(\d)+\.(\d)+.(\d)+$/);
    if (match) {
      const [_, major, minor] = match;
      if (major < '6' || (major === '6' && minor < '4')) {
        const recorder = host.beginUpdate(packageJson);
        replacePropertyInAstObject(recorder, deps, 'rxjs', '~6.4.0');
        host.commitUpdate(recorder);
      }
    } else {
      context.logger.info(
          'Could not determine version of rxjs. \n' +
          'Please make sure that version is at least 6.4.0.');
    }
    return host;
  };
}

/**
 * When using Angular NPM packages and building with AOT compilation, ngc
 * requires ngsumamry files but they are not shipped. This function adds a
 * postinstall step to generate these files.
 */
function addPostinstallToGenerateNgSummaries(options: Schema) {
  return (host: Tree, context: SchematicContext) => {
    const angularMetadataTsConfig = `${options.name}/angular-metadata.tsconfig.json`;
    if (!host.exists(angularMetadataTsConfig)) {
      return;
    }
    const packageJson = `${options.name}/package.json`;
    if (!host.exists(packageJson)) {
      throw new Error(`Could not find ${packageJson}`);
    }
    const content = host.read(packageJson).toString();
    const jsonAst = parseJsonAst(content) as JsonAstObject;
    const scripts = findPropertyInAstObject(jsonAst, 'scripts') as JsonAstObject;
    const recorder = host.beginUpdate(packageJson);
    if (scripts) {
      insertPropertyInAstObjectInOrder(
          recorder, scripts, 'postinstall', 'ngc -p ./angular-metadata.tsconfig.json', 4);
    } else {
      insertPropertyInAstObjectInOrder(
          recorder, jsonAst, 'scripts', {
            postinstall: 'ngc -p ./angular-metadata.tsconfig.json',
          },
          2);
    }
    host.commitUpdate(recorder);
    return host;
  };
}

export default function(options: Schema): Rule {
  return (host: Tree) => {
    validateProjectName(options.name);

    return chain([
      externalSchematic(
          '@schematics/angular', 'ng-new',
          {
              ...options,
          }),
      addDevDependenciesToPackageJson(options),
      upgradeRxjs(options),
      addDevAndProdMainForAot(options),
      schematic('bazel-workspace', options, {
        scope: options.name,
      }),
      overwriteGitignore(options),
      addPostinstallToGenerateNgSummaries(options),
      updateWorkspaceFileToUseBazelBuilder(options),
    ]);
  };
}
