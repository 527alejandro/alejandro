/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Transform template html and css into executable code.
 * Intended to be used in a build step.
 */
import * as compiler from '@angular/compiler';
import {I18nVersion, MissingTranslationStrategy} from '@angular/core';
import {AngularCompilerOptions, NgcCliOptions} from '@angular/tsc-wrapped';
import {readFileSync} from 'fs';
import * as glob from 'glob';
import * as ts from 'typescript';

import {CompilerHost, CompilerHostContext, ModuleResolutionHostAdapter} from './compiler_host';
import {PathMappedCompilerHost} from './path_mapped_compiler_host';

const GENERATED_META_FILES = /\.json$/;

const PREAMBLE = `/**
 * @fileoverview This file is generated by the Angular template compiler.
 * Do not edit.
 * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride}
 */
 /* tslint:disable */

`;

export class CodeGenerator {
  constructor(
      private options: AngularCompilerOptions, private program: ts.Program,
      public host: ts.CompilerHost, private compiler: compiler.AotCompiler,
      private ngCompilerHost: CompilerHost) {}

  codegen(): Promise<string[]> {
    return this.compiler
        .analyzeModulesAsync(this.program.getSourceFiles().map(
            sf => this.ngCompilerHost.getCanonicalFileName(sf.fileName)))
        .then(analyzedModules => this.emit(analyzedModules));
  }

  codegenSync(): string[] {
    const analyzed = this.compiler.analyzeModulesSync(this.program.getSourceFiles().map(
        sf => this.ngCompilerHost.getCanonicalFileName(sf.fileName)));
    return this.emit(analyzed);
  }

  private emit(analyzedModules: compiler.NgAnalyzedModules) {
    const generatedModules = this.compiler.emitAllImpls(analyzedModules);
    return generatedModules.map(generatedModule => {
      const sourceFile = this.program.getSourceFile(generatedModule.srcFileUrl);
      const emitPath = this.ngCompilerHost.calculateEmitPath(generatedModule.genFileUrl);
      const source = generatedModule.source || compiler.toTypeScript(generatedModule, PREAMBLE);
      this.host.writeFile(emitPath, source, false, () => {}, [sourceFile]);
      return emitPath;
    });
  }

  static create(
      options: AngularCompilerOptions, cliOptions: NgcCliOptions, program: ts.Program,
      tsCompilerHost: ts.CompilerHost, compilerHostContext?: CompilerHostContext,
      ngCompilerHost?: CompilerHost): CodeGenerator {
    if (!ngCompilerHost) {
      const usePathMapping = !!options.rootDirs && options.rootDirs.length > 0;
      const context = compilerHostContext || new ModuleResolutionHostAdapter(tsCompilerHost);
      ngCompilerHost = usePathMapping ? new PathMappedCompilerHost(program, options, context) :
                                        new CompilerHost(program, options, context);
    }

    const {compiler: aotCompiler} = compiler.createAotCompiler(ngCompilerHost, {
      translations: getTranslations(cliOptions.i18nFile),
      missingTranslation: normalizeMissingTranslationStrategy(cliOptions.missingTranslation),
      i18nFormat: normalizeI18nFormat(cliOptions.i18nFormat),
      locale: cliOptions.locale,
      i18nVersion: normalizeI18nVersion(cliOptions.i18nVersion),
      enableLegacyTemplate: options.enableLegacyTemplate !== false,
    });

    return new CodeGenerator(options, program, tsCompilerHost, aotCompiler, ngCompilerHost);
  }
}

/**
 * @internal
 */
export function getTranslations(i18nFile: string | null): string {
  if (i18nFile) {
    return readFileSync(i18nFile, 'utf8');
  }
  return '';
}

/**
 * @internal
 */
export function normalizeI18nFormat(i18nFormat?: string | null): string {
  return i18nFormat || 'xlf';
}

/**
 * @internal
 */
export function normalizeMapping(mapping?: string | boolean | null): boolean {
  return typeof mapping !== 'undefined' && mapping !== 'false' && mapping !== null;
}

/**
 * @internal
 */
export function normalizeResolve(resolve?: string | null): string {
  return resolve === 'auto' ? 'auto' : 'manual';
}

/**
 * @internal
 */
export function normalizeMissingTranslationStrategy(missingTranslation?: string | null):
    MissingTranslationStrategy {
  if (missingTranslation) {
    switch (missingTranslation) {
      case 'error':
        return MissingTranslationStrategy.Error;
      case 'warning':
        return MissingTranslationStrategy.Warning;
      case 'ignore':
        return MissingTranslationStrategy.Ignore;
      default:
        throw new Error(
            `Unknown option for missingTranslation (${missingTranslation}). Use either error, warning or ignore.`);
    }
  }
  return MissingTranslationStrategy.Warning;
}

/**
 * @internal
 */
export function normalizeI18nVersion(i18nVersion?: string | null): I18nVersion {
  if (i18nVersion) {
    switch (i18nVersion) {
      case '0':
        return I18nVersion.Version0;
      case '1':
        return I18nVersion.Version1;
      default:
        throw new Error(`Unknown option for i18nVersion (${i18nVersion}). Use either 0 or 1.`);
    }
  }
  return I18nVersion.Version0;
}

/**
 * @internal
 */
export function resolveFiles(files?: string | null): string[] {
  if (!files) {
    throw new Error(`The translations files must be provided. Use the --files option.`);
  }
  return glob.sync(files);
}
