"use strict";function _interopDefault(e){return e&&"object"==typeof e&&"default"in e?e.default:e}var yargs=require("yargs"),tslib=require("tslib"),chalk=_interopDefault(require("chalk")),fs=require("fs"),inquirer=require("inquirer"),inquirerAutocomplete=require("inquirer-autocomplete-prompt"),path=require("path"),shelljs=require("shelljs"),url=require("url"),child_process=require("child_process"),graphql=require("@octokit/graphql"),OctokitType=require("@octokit/rest"),typedGraphqlify=require("typed-graphqlify"),fetch=_interopDefault(require("node-fetch")),multimatch=require("multimatch"),yaml=require("yaml"),cliProgress=require("cli-progress"),os=require("os"),minimatch=require("minimatch"),semver=require("semver"),Ora=require("ora"),glob=require("glob"),ts=require("typescript");function exec(e,t){return shelljs.exec(e,tslib.__assign(tslib.__assign({silent:!0},t),{async:!1}))}function isTsNodeAvailable(){try{return require.resolve("ts-node"),!0}catch(e){return!1}}var CONFIG_FILE_PATH=".ng-dev/config",cachedConfig=null,USER_CONFIG_FILE_PATH=".ng-dev.user",userConfig=null;function getConfig(){if(null===cachedConfig){var e=path.join(getRepoBaseDir(),CONFIG_FILE_PATH);cachedConfig=validateCommonConfig(readConfigFile(e))}return tslib.__assign({},cachedConfig)}function validateCommonConfig(e){var t=[];return void 0===e.github?t.push('Github repository not configured. Set the "github" option.'):(void 0===e.github.name&&t.push('"github.name" is not defined'),void 0===e.github.owner&&t.push('"github.owner" is not defined')),assertNoErrors(t),e}function readConfigFile(e,t){void 0===t&&(t=!1),void 0===require.extensions[".ts"]&&fs.existsSync(e+".ts")&&isTsNodeAvailable()&&require("ts-node").register({dir:path.dirname(e),transpileOnly:!0,compilerOptions:{module:"commonjs"}});try{return require(e)}catch(r){if(t)return debug("Could not read configuration file at "+e+", returning empty object instead."),debug(r),{};error("Could not read configuration file at "+e+"."),error(r),process.exit(1)}}function assertNoErrors(e){var t,r;if(0!=e.length){error("Errors discovered while loading configuration file:");try{for(var n=tslib.__values(e),i=n.next();!i.done;i=n.next())error("  - "+i.value)}catch(e){t={error:e}}finally{try{i&&!i.done&&(r=n.return)&&r.call(n)}finally{if(t)throw t.error}}process.exit(1)}}function getRepoBaseDir(){var e=exec("git rev-parse --show-toplevel");if(e.code)throw Error("Unable to find the path to the base directory of the repository.\nWas the command run from inside of the repo?\n\nERROR:\n "+e.stderr);return e.trim()}function getUserConfig(){if(null===userConfig){var e=path.join(getRepoBaseDir(),USER_CONFIG_FILE_PATH);userConfig=readConfigFile(e,!0)}return tslib.__assign({},userConfig)}var LOG_LEVELS,red=chalk.red,green=chalk.green,yellow=chalk.yellow,bold=chalk.bold,blue=chalk.blue;function promptConfirm(e,t){return void 0===t&&(t=!1),tslib.__awaiter(this,void 0,void 0,(function(){return tslib.__generator(this,(function(r){switch(r.label){case 0:return[4,inquirer.prompt({type:"confirm",name:"result",message:e,default:t})];case 1:return[2,r.sent().result]}}))}))}function promptAutocomplete(e,t,r){return tslib.__awaiter(this,void 0,void 0,(function(){var n,i;return tslib.__generator(this,(function(o){switch(o.label){case 0:return n=inquirer.createPromptModule({}).registerPrompt("autocomplete",inquirerAutocomplete),r&&(t=tslib.__spread([r],t)),[4,n({type:"autocomplete",name:"result",message:e,source:function(e,r){return Promise.resolve(r?t.filter((function(e){return"string"==typeof e?e.includes(r):e.name.includes(r)})):t)}})];case 1:return(i=o.sent().result)===r?[2,!1]:[2,i]}}))}))}function promptInput(e){return tslib.__awaiter(this,void 0,void 0,(function(){return tslib.__generator(this,(function(t){switch(t.label){case 0:return[4,inquirer.prompt({type:"input",name:"result",message:e})];case 1:return[2,t.sent().result]}}))}))}!function(e){e[e.SILENT=0]="SILENT",e[e.ERROR=1]="ERROR",e[e.WARN=2]="WARN",e[e.LOG=3]="LOG",e[e.INFO=4]="INFO",e[e.DEBUG=5]="DEBUG"}(LOG_LEVELS||(LOG_LEVELS={}));var DEFAULT_LOG_LEVEL=LOG_LEVELS.INFO,info=buildLogLevelFunction((function(){return console.info}),LOG_LEVELS.INFO),error=buildLogLevelFunction((function(){return console.error}),LOG_LEVELS.ERROR),debug=buildLogLevelFunction((function(){return console.debug}),LOG_LEVELS.DEBUG),log=buildLogLevelFunction((function(){return console.log}),LOG_LEVELS.LOG),warn=buildLogLevelFunction((function(){return console.warn}),LOG_LEVELS.WARN);function buildLogLevelFunction(e,t){var r=function(){for(var r=[],n=0;n<arguments.length;n++)r[n]=arguments[n];runConsoleCommand.apply(void 0,tslib.__spread([e,t],r))};return r.group=function(e,r){void 0===r&&(r=!1);var n=r?console.groupCollapsed:console.group;runConsoleCommand((function(){return n}),t,e)},r.groupEnd=function(){runConsoleCommand((function(){return console.groupEnd}),t)},r}function runConsoleCommand(e,t){for(var r=[],n=2;n<arguments.length;n++)r[n-2]=arguments[n];getLogLevel()>=t&&e().apply(void 0,tslib.__spread(r)),printToLogFile.apply(void 0,tslib.__spread([t],r))}function getLogLevel(){var e=(process.env.LOG_LEVEL||"").toUpperCase(),t=LOG_LEVELS[e];return void 0===t?DEFAULT_LOG_LEVEL:t}var LOGGED_TEXT="",FILE_LOGGING_ENABLED=!1,LOG_LEVEL_COLUMNS=7;function captureLogOutputForCommand(e){if(FILE_LOGGING_ENABLED)throw Error("`captureLogOutputForCommand` cannot be called multiple times");var t=new Date,r=Array(100).fill("#").join("");LOGGED_TEXT+=r+"\nCommand: "+e.$0+" "+e._.join(" ")+"\nRan at: "+t+"\n",process.on("exit",(function(e){LOGGED_TEXT+="Command ran in "+((new Date).getTime()-t.getTime())+"ms";var r=path.join(getRepoBaseDir(),".ng-dev.log");LOGGED_TEXT=LOGGED_TEXT.replace(/\x1B\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]/g,""),fs.writeFileSync(r,LOGGED_TEXT),e>1&&fs.writeFileSync(path.join(getRepoBaseDir(),".ng-dev.err-"+t.getTime()+".log"),LOGGED_TEXT)})),FILE_LOGGING_ENABLED=!0}function printToLogFile(e){for(var t=[],r=1;r<arguments.length;r++)t[r-1]=arguments[r];var n=(LOG_LEVELS[e]+":").padEnd(LOG_LEVEL_COLUMNS);LOGGED_TEXT+=t.join(" ").split("\n").map((function(e){return n+" "+e+"\n"})).join("")}var GITHUB_TOKEN_SETTINGS_URL="https://github.com/settings/tokens",GITHUB_TOKEN_GENERATE_URL="https://github.com/settings/tokens/new";function addTokenToGitHttpsUrl(e,t){var r=new url.URL(e);return r.username=t,r.toString()}function getRepositoryGitUrl(e,t){if(e.useSsh)return"git@github.com:"+e.owner+"/"+e.name+".git";var r="https://github.com/"+e.owner+"/"+e.name+".git";return void 0!==t?addTokenToGitHttpsUrl(r,t):r}function getListCommitsInBranchUrl(e,t){var r=e.remoteParams;return"https://github.com/"+r.owner+"/"+r.repo+"/commits/"+t}function addGithubTokenOption(e){return e.option("github-token",{type:"string",description:"Github token. If not set, token is retrieved from the environment variables.",coerce:function(e){var t=e||process.env.GITHUB_TOKEN||process.env.TOKEN;return t||(error(red("No Github token set. Please set the `GITHUB_TOKEN` environment variable.")),error(red("Alternatively, pass the `--github-token` command line flag.")),error(yellow("You can generate a token here: "+GITHUB_TOKEN_GENERATE_URL)),process.exit(1)),t}}).default("github-token","","<LOCAL TOKEN>")}var ServiceStatus,GithubApiRequestError=function(e){function t(t,r){var n=e.call(this,r)||this;return n.status=t,n}return tslib.__extends(t,e),t}(Error),GithubClient=function(e){function t(t){var r=e.call(this,{auth:t})||this;return r._currentUser=null,r.hook.error("request",(function(e){throw new GithubApiRequestError(e.status,e.message)})),r.graphql=new GithubGraphqlClient(t),r}return tslib.__extends(t,e),t.prototype.getCurrentUser=function(){return tslib.__awaiter(this,void 0,void 0,(function(){var e;return tslib.__generator(this,(function(t){switch(t.label){case 0:return null!==this._currentUser?[2,this._currentUser]:[4,this.graphql.query({viewer:{login:typedGraphqlify.types.string}})];case 1:return e=t.sent(),[2,this._currentUser=e.viewer.login]}}))}))},t}(OctokitType),GithubGraphqlClient=function(){function e(e){this.graqhql=graphql.graphql,e&&(this.graqhql=this.graqhql.defaults({headers:{authorization:"token "+e}}))}return e.prototype.query=function(e,t){return void 0===t&&(t={}),tslib.__awaiter(this,void 0,void 0,(function(){var r;return tslib.__generator(this,(function(n){switch(n.label){case 0:return r=typedGraphqlify.query(e),[4,this.graqhql(r,t)];case 1:return[2,n.sent()]}}))}))},e}(),GitCommandError=function(e){function t(t,r){var n=e.call(this,"Command failed: git "+t.omitGithubTokenFromMessage(r.join(" ")))||this;return n.args=r,n}return tslib.__extends(t,e),t}(Error),GitClient=function(){function e(e,t,r){void 0===t&&(t=getConfig()),void 0===r&&(r=getRepoBaseDir()),this.githubToken=e,this._config=t,this._projectRoot=r,this.remoteConfig=this._config.github,this.remoteParams={owner:this.remoteConfig.owner,repo:this.remoteConfig.name},this.repoGitUrl=getRepositoryGitUrl(this.remoteConfig,this.githubToken),this.github=new GithubClient(this.githubToken),this._cachedOauthScopes=null,this._githubTokenRegex=null,null!=e&&(this._githubTokenRegex=new RegExp(e,"g"))}return e.prototype.run=function(e,t){var r=this.runGraceful(e,t);if(0!==r.status)throw new GitCommandError(this,e);return r},e.prototype.runGraceful=function(e,t){void 0===t&&(t={}),("ignore"!==t.stdio?info:debug)("Executing: git",this.omitGithubTokenFromMessage(e.join(" ")));var r=child_process.spawnSync("git",e,tslib.__assign(tslib.__assign({cwd:this._projectRoot,stdio:"pipe"},t),{encoding:"utf8"}));return null!==r.stderr&&process.stderr.write(this.omitGithubTokenFromMessage(r.stderr)),r},e.prototype.hasCommit=function(e,t){return""!==this.run(["branch",e,"--contains",t]).stdout},e.prototype.getCurrentBranchOrRevision=function(){var e=this.run(["rev-parse","--abbrev-ref","HEAD"]).stdout.trim();return"HEAD"===e?this.run(["rev-parse","HEAD"]).stdout.trim():e},e.prototype.hasUncommittedChanges=function(){return 0!==this.runGraceful(["diff-index","--quiet","HEAD"]).status},e.prototype.hasLocalChanges=function(){return 0!==this.runGraceful(["diff-index","--quiet","HEAD"]).status},e.prototype.omitGithubTokenFromMessage=function(e){return null===this._githubTokenRegex?e:e.replace(this._githubTokenRegex,"<TOKEN>")},e.prototype.checkout=function(e,t){return t&&(this.runGraceful(["am","--abort"],{stdio:"ignore"}),this.runGraceful(["cherry-pick","--abort"],{stdio:"ignore"}),this.runGraceful(["rebase","--abort"],{stdio:"ignore"}),this.runGraceful(["reset","--hard"],{stdio:"ignore"})),0===this.runGraceful(["checkout",e],{stdio:"ignore"}).status},e.prototype.hasOauthScopes=function(e){return tslib.__awaiter(this,void 0,void 0,(function(){var t,r;return tslib.__generator(this,(function(n){switch(n.label){case 0:return[4,this.getAuthScopesForToken()];case 1:return t=n.sent(),e(t,r=[]),0===r.length?[2,!0]:[2,{error:"The provided <TOKEN> does not have required permissions due to missing scope(s): "+yellow(r.join(", "))+"\n\nUpdate the token in use at:\n  "+GITHUB_TOKEN_SETTINGS_URL+"\n\nAlternatively, a new token can be created at: "+GITHUB_TOKEN_GENERATE_URL+"\n"}]}}))}))},e.prototype.getAuthScopesForToken=function(){return tslib.__awaiter(this,void 0,void 0,(function(){return tslib.__generator(this,(function(e){return null!==this._cachedOauthScopes?[2,this._cachedOauthScopes]:[2,this._cachedOauthScopes=this.github.rateLimit.get().then((function(e){return(e.headers["x-oauth-scopes"]||"").split(",").map((function(e){return e.trim()}))}))]}))}))},e}();function getCaretakerConfig(){var e=getConfig();return assertNoErrors([]),e}function printCiStatus(e){return tslib.__awaiter(this,void 0,void 0,(function(){return tslib.__generator(this,(function(t){switch(t.label){case 0:return info.group(bold("CI")),[4,printStatus(e,"master")];case 1:return t.sent(),info.groupEnd(),info(),[2]}}))}))}function printStatus(e,t){return tslib.__awaiter(this,void 0,void 0,(function(){var r,n;return tslib.__generator(this,(function(i){switch(i.label){case 0:return[4,getStatusOfBranch(e,t)];case 1:return r=i.sent(),n=t.padEnd(10),info(null===r?n+" was not found on CircleCI":"success"===r.status?n+" ✅":n+" ❌ (Ran at: "+r.timestamp.toLocaleString()+")"),[2]}}))}))}function getStatusOfBranch(e,t){var r;return tslib.__awaiter(this,void 0,void 0,(function(){var n,i;return tslib.__generator(this,(function(o){switch(o.label){case 0:return[4,fetch("https://circleci.com/api/v1.1/project/gh/"+(n=e.remoteConfig).owner+"/"+n.name+"/tree/"+t+"?limit=1&filter=completed&shallow=true").then((function(e){return e.json()}))];case 1:return(i=null===(r=o.sent())||void 0===r?void 0:r[0])?[2,{status:i.outcome,timestamp:new Date(i.stop_time),buildUrl:i.build_url}]:[2,null]}}))}))}function printG3Comparison(e){var t,r,n,i;return tslib.__awaiter(this,void 0,void 0,(function(){var o,a,s,u,c,l,h,d,f;return tslib.__generator(this,(function(p){if(o=path.join(getRepoBaseDir(),".github/angular-robot.yml"),!fs.existsSync(o))return[2,debug("No angular robot configuration file exists, skipping.")];if(a=yaml.parse(fs.readFileSync(o).toString()),s=(null===(r=null===(t=null==a?void 0:a.merge)||void 0===t?void 0:t.g3Status)||void 0===r?void 0:r.include)||[],u=(null===(i=null===(n=null==a?void 0:a.merge)||void 0===n?void 0:n.g3Status)||void 0===i?void 0:i.exclude)||[],0===s.length&&0===u.length)return debug("No g3Status include or exclude lists are defined in the angular robot configuration,"),debug("skipping."),[2];if(c="prefix"+Math.floor(1e6*Math.random()),0!==(d=e.runGraceful(["fetch","-q","https://github.com/"+e.remoteConfig.owner+"/"+e.remoteConfig.name+".git","master:"+(l=c+"-master"),"g3:"+(h=c+"-g3")])).status){if(d.stderr.includes("couldn't find remote ref g3"))return[2,debug("No g3 branch exists on upstream, skipping.")];throw Error("Fetch of master and g3 branches for comparison failed.")}return f=function g(e){var t={insertions:0,deletions:0,files:0,commits:0};return t.commits=parseInt(e.run(["rev-list","--count",h+".."+l]).stdout,10),e.run(["diff",h+"..."+l,"--numstat"]).stdout.trim().split("\n").map((function(e){return e.split("\t")})).map((function(e){return[Number(e[0]),Number(e[1]),e[2]]})).forEach((function(e){var r=tslib.__read(e,3),n=r[0],i=r[1];(function o(e,t,r){return multimatch.call(void 0,e,t).length>=1&&0===multimatch.call(void 0,e,r).length})(r[2],s,u)&&(t.insertions+=n,t.deletions+=i,t.files+=1)})),t}(e),e.runGraceful(["branch","-D",l,h]),info.group(bold("g3 branch check")),info(f.commits+" commits between g3 and master"),info(0===f.files?"✅ No sync is needed at this time":f.files+" files changed, "+f.insertions+" insertions(+), "+f.deletions+" deletions(-) will be included in the next sync"),info.groupEnd(),info(),[2]}))}))}function printGithubTasks(e,t){var r;return tslib.__awaiter(this,void 0,void 0,(function(){return tslib.__generator(this,(function(n){switch(n.label){case 0:return(null===(r=null==t?void 0:t.githubQueries)||void 0===r?void 0:r.length)?(info.group(bold("Github Tasks")),[4,getGithubInfo(e,t)]):(debug("No github queries defined in the configuration, skipping."),[2]);case 1:return n.sent(),info.groupEnd(),info(),[2]}}))}))}function getGithubInfo(e,t){var r=t.githubQueries,n=void 0===r?[]:r;return tslib.__awaiter(this,void 0,void 0,(function(){var t,r,i;return tslib.__generator(this,(function(o){switch(o.label){case 0:return t={},r="repo:"+e.remoteConfig.owner+"/"+e.remoteConfig.name,n.forEach((function(e){var n=e.query,i=typedGraphqlify.alias(e.name.replace(/ /g,""),"search");t[i]=typedGraphqlify.params({type:"ISSUE",query:'"'+r+" "+n.replace(/"/g,'\\"')+'"'},{issueCount:typedGraphqlify.types.number})})),[4,e.github.graphql.query(t)];case 1:return i=o.sent(),Object.values(i).forEach((function(e,t){var r;info((null===(r=n[t])||void 0===r?void 0:r.name.padEnd(25))+" "+e.issueCount)})),[2]}}))}))}function printServiceStatuses(){return tslib.__awaiter(this,void 0,void 0,(function(){var e,t,r,n,i,o,a,s;return tslib.__generator(this,(function(u){switch(u.label){case 0:return info.group(bold("Service Statuses (checked: "+(new Date).toLocaleString()+")")),e=logStatus,t=["CircleCI"],[4,getCircleCiStatus()];case 1:return e.apply(void 0,t.concat([u.sent()])),r=logStatus,n=["Github"],[4,getGithubStatus()];case 2:return r.apply(void 0,n.concat([u.sent()])),i=logStatus,o=["NPM"],[4,getNpmStatus()];case 3:return i.apply(void 0,o.concat([u.sent()])),a=logStatus,s=["Saucelabs"],[4,getSaucelabsStatus()];case 4:return a.apply(void 0,s.concat([u.sent()])),info.groupEnd(),info(),[2]}}))}))}function logStatus(e,t){e=e.padEnd(15),t.status===ServiceStatus.GREEN?info(e+" "+green("✅")):t.status===ServiceStatus.RED&&(info.group(e+" "+red("❌")+" (Updated: "+t.lastUpdated.toLocaleString()+")"),info("  Details: "+t.description),info.groupEnd())}function getSaucelabsStatus(){return tslib.__awaiter(this,void 0,void 0,(function(){return tslib.__generator(this,(function(e){return[2,getStatusFromStandardApi("https://status.us-west-1.saucelabs.com/api/v2/status.json")]}))}))}function getNpmStatus(){return tslib.__awaiter(this,void 0,void 0,(function(){return tslib.__generator(this,(function(e){return[2,getStatusFromStandardApi("https://status.npmjs.org/api/v2/status.json")]}))}))}function getCircleCiStatus(){return tslib.__awaiter(this,void 0,void 0,(function(){return tslib.__generator(this,(function(e){return[2,getStatusFromStandardApi("https://status.circleci.com/api/v2/status.json")]}))}))}function getGithubStatus(){return tslib.__awaiter(this,void 0,void 0,(function(){return tslib.__generator(this,(function(e){return[2,getStatusFromStandardApi("https://www.githubstatus.com/api/v2/status.json")]}))}))}function getStatusFromStandardApi(e){return tslib.__awaiter(this,void 0,void 0,(function(){var t;return tslib.__generator(this,(function(r){switch(r.label){case 0:return[4,fetch(e).then((function(e){return e.json()}))];case 1:return[2,{status:"none"===(t=r.sent()).status.indicator?ServiceStatus.GREEN:ServiceStatus.RED,description:t.status.description,lastUpdated:new Date(t.page.updated_at)}]}}))}))}function checkServiceStatuses(e){return tslib.__awaiter(this,void 0,void 0,(function(){var t,r;return tslib.__generator(this,(function(n){switch(n.label){case 0:return t=getCaretakerConfig(),r=new GitClient(e,t),[4,printServiceStatuses()];case 1:return n.sent(),[4,printGithubTasks(r,t.caretaker)];case 2:return n.sent(),[4,printG3Comparison(r)];case 3:return n.sent(),[4,printCiStatus(r)];case 4:return n.sent(),[2]}}))}))}function builder(e){return addGithubTokenOption(e)}function handler(e){var t=e.githubToken;return tslib.__awaiter(this,void 0,void 0,(function(){return tslib.__generator(this,(function(e){switch(e.label){case 0:return[4,checkServiceStatuses(t)];case 1:return e.sent(),[2]}}))}))}!function(e){e[e.GREEN=0]="GREEN",e[e.RED=1]="RED"}(ServiceStatus||(ServiceStatus={}));var CheckModule={handler:handler,builder:builder,command:"check",describe:"Check the status of information the caretaker manages for the repository"};function buildCaretakerParser(e){return e.command(CheckModule)}function loadCommitMessageDraft(e){var t=e+".ngDevSave";return fs.existsSync(t)?fs.readFileSync(t).toString():""}function deleteCommitMessageDraft(e){var t=e+".ngDevSave";fs.existsSync(t)&&fs.unlinkSync(t)}function saveCommitMessageDraft(e,t){fs.writeFileSync(e+".ngDevSave",t)}function restoreCommitMessage(e,t){t&&(log("Skipping commit message restoration attempt"),"message"===t&&debug("A commit message was already provided via the command with a -m or -F flag"),"template"===t&&debug("A commit message was already provided via the -t flag or config.template setting"),"squash"===t&&debug("A commit message was already provided as a merge action or via .git/MERGE_MSG"),"commit"===t&&(debug("A commit message was already provided through a revision specified via --fixup, -c,"),debug("-C or --amend flag")),process.exit(0));var r=loadCommitMessageDraft(e);r&&fs.writeFileSync(e,r),process.exit(0)}function builder$1(e){return e.option("file-env-variable",{type:"string",array:!0,demandOption:!0,description:"The key for the environment variable which holds the arguments for the\nprepare-commit-msg hook as described here:\nhttps://git-scm.com/docs/githooks#_prepare_commit_msg",coerce:function(e){var t=tslib.__read((process.env[e]||"").split(" "),2),r=t[0],n=t[1];if(!r)throw new Error('Provided environment variable "'+e+'" was not found.');return[r,n]}})}function handler$1(e){var t=e.fileEnvVariable;return tslib.__awaiter(this,void 0,void 0,(function(){return tslib.__generator(this,(function(e){return restoreCommitMessage(t[0],t[1]),[2]}))}))}var ScopeRequirement,RestoreCommitMessageModule={handler:handler$1,builder:builder$1,command:"restore-commit-message-draft",describe:!1};function getCommitMessageConfig(){var e=[],t=getConfig();return void 0===t.commitMessage&&e.push('No configuration defined for "commitMessage"'),assertNoErrors(e),t}!function(e){e[e.Required=0]="Required",e[e.Optional=1]="Optional",e[e.Forbidden=2]="Forbidden"}(ScopeRequirement||(ScopeRequirement={}));var COMMIT_TYPES={build:{name:"build",description:"Changes to local repository build system and tooling",scope:ScopeRequirement.Optional},ci:{name:"ci",description:"Changes to CI configuration and CI specific tooling",scope:ScopeRequirement.Forbidden},docs:{name:"docs",description:"Changes which exclusively affects documentation.",scope:ScopeRequirement.Optional},feat:{name:"feat",description:"Creates a new feature",scope:ScopeRequirement.Required},fix:{name:"fix",description:"Fixes a previously discovered failure/bug",scope:ScopeRequirement.Required},perf:{name:"perf",description:"Improves performance without any change in functionality or API",scope:ScopeRequirement.Required},refactor:{name:"refactor",description:"Refactor without any change in functionality or API (includes style changes)",scope:ScopeRequirement.Required},release:{name:"release",description:"A release point in the repository",scope:ScopeRequirement.Forbidden},test:{name:"test",description:"Improvements or corrections made to the project's test suite",scope:ScopeRequirement.Required}},FIXUP_PREFIX_RE=/^fixup! /i,GITHUB_LINKING_RE=/((closed?s?)|(fix(es)?(ed)?)|(resolved?s?))\s\#(\d+)/gi,SQUASH_PREFIX_RE=/^squash! /i,REVERT_PREFIX_RE=/^revert:? /i,TYPE_SCOPE_RE=/^(\w+)(?:\(([^)]+)\))?\:\s(.+)$/,COMMIT_HEADER_RE=/^(.*)/i,COMMIT_BODY_RE=/^.*\n\n([\s\S]*)$/;function parseCommitMessage(e){e=e.split("\n").filter((function(e){return!e.startsWith("#")})).join("\n");var t="",r="",n="",i="",o="",a="";if(COMMIT_HEADER_RE.test(e)&&(t=COMMIT_HEADER_RE.exec(e)[1].replace(FIXUP_PREFIX_RE,"").replace(SQUASH_PREFIX_RE,"")),COMMIT_BODY_RE.test(e)&&(n=(r=COMMIT_BODY_RE.exec(e)[1]).replace(GITHUB_LINKING_RE,"")),TYPE_SCOPE_RE.test(t)){var s=TYPE_SCOPE_RE.exec(t);i=s[1],o=s[2],a=s[3]}return{header:t,body:r,bodyWithoutLinking:n,type:i,scope:o,subject:a,isFixup:FIXUP_PREFIX_RE.test(e),isSquash:SQUASH_PREFIX_RE.test(e),isRevert:REVERT_PREFIX_RE.test(e)}}var COMMIT_BODY_URL_LINE_RE=/^https?:\/\/.*$/;function validateCommitMessage(e,t){void 0===t&&(t={});var r=getCommitMessageConfig().commitMessage,n=parseCommitMessage(e),i=[];return{valid:function o(){var e;if(n.isRevert)return!0;if(n.isSquash)return!t.disallowSquash||(i.push("The commit must be manually squashed into the target commit"),!1);if(n.isFixup)return!(t.nonFixupCommitHeaders&&!t.nonFixupCommitHeaders.includes(n.header)&&(i.push("Unable to find match for fixup commit among prior commits: "+(t.nonFixupCommitHeaders.map((function(e){return"\n      "+e})).join("")||"-")),1));if(n.header.length>r.maxLineLength)return i.push("The commit message header is longer than "+r.maxLineLength+" characters"),!1;if(!n.type)return i.push("The commit message header does not match the expected format."),!1;if(void 0===COMMIT_TYPES[n.type])return i.push("'"+n.type+"' is not an allowed type.\n => TYPES: "+Object.keys(COMMIT_TYPES).join(", ")),!1;var o=COMMIT_TYPES[n.type].scope;return o===ScopeRequirement.Forbidden&&n.scope?(i.push("Scopes are forbidden for commits with type '"+n.type+"', but a scope of '"+n.scope+"' was provided."),!1):o!==ScopeRequirement.Required||n.scope?n.scope&&!r.scopes.includes(n.scope)?(i.push("'"+n.scope+"' is not an allowed scope.\n => SCOPES: "+r.scopes.join(", ")),!1):"release"===n.type||(!(null===(e=r.minBodyLengthTypeExcludes)||void 0===e?void 0:e.includes(n.type))&&n.bodyWithoutLinking.trim().length<r.minBodyLength?(i.push("The commit message body does not meet the minimum length of "+r.minBodyLength+" characters"),!1):!n.body.split("\n").some((function(e){return e.length>r.maxLineLength&&!COMMIT_BODY_URL_LINE_RE.test(e)}))||(i.push("The commit message body contains lines greater than "+r.maxLineLength+" characters"),!1)):(i.push("Scopes are required for commits with type '"+n.type+"', but no scope was provided."),!1)}(),errors:i,commit:n}}function printValidationErrors(e,t){void 0===t&&(t=error),t.group("Error"+(1===e.length?"":"s")+":"),e.forEach((function(e){return t(e)})),t.groupEnd(),t(),t("The expected format for a commit is: "),t("<type>(<scope>): <summary>"),t(),t("<body>"),t()}function validateFile(e,t){var r=fs.readFileSync(path.resolve(getRepoBaseDir(),e),"utf8"),n=validateCommitMessage(r),i=n.errors;if(n.valid)return info(green("√")+"  Valid commit message"),deleteCommitMessageDraft(e),void(process.exitCode=0);var o=t?error:log;o((t?red("✘"):yellow("!"))+"  Invalid commit message"),printValidationErrors(i,o),t?(o(red("Aborting commit attempt due to invalid commit message.")),o(red("Commit message aborted as failure rather than warning due to local configuration."))):(o(yellow("Before this commit can be merged into the upstream repository, it must be")),o(yellow("amended to follow commit message guidelines."))),saveCommitMessageDraft(e,r),process.exitCode=t?1:0}function builder$2(e){var t;return e.option("file",{type:"string",conflicts:["file-env-variable"],description:"The path of the commit message file."}).option("file-env-variable",{type:"string",conflicts:["file"],description:"The key of the environment variable for the path of the commit message file.",coerce:function(e){var t=process.env[e];if(!t)throw new Error('Provided environment variable "'+e+'" was not found.');return t}}).option("error",{type:"boolean",description:"Whether invalid commit messages should be treated as failures rather than a warning",default:!!(null===(t=getUserConfig().commitMessage)||void 0===t?void 0:t.errorOnInvalidMessage)||!!process.env.CI})}function handler$2(e){var t=e.error,r=e.file,n=e.fileEnvVariable;return tslib.__awaiter(this,void 0,void 0,(function(){return tslib.__generator(this,(function(e){return validateFile(r||n||".git/COMMIT_EDITMSG",t),[2]}))}))}var ValidateFileModule={handler:handler$2,builder:builder$2,command:"pre-commit-validate",describe:"Validate the most recent commit message"},isNonFixup=function(e){return!parseCommitMessage(e).isFixup},extractCommitHeader=function(e){return parseCommitMessage(e).header};function validateCommitRange(e){var t=""+Math.random(),r=[],n=exec("git log --reverse --format=%s%n%n%b"+t+" "+e);if(n.code)throw new Error("Failed to get all commits in the range: \n  "+n.stderr);var i=n.split(t).map((function(e){return e.trim()})).filter((function(e){return!!e}));info("Examining "+i.length+" commit(s) in the provided range: "+e),i.every((function(e,t){var n=validateCommitMessage(e,{disallowSquash:!0,nonFixupCommitHeaders:isNonFixup(e)?void 0:i.slice(0,t).filter(isNonFixup).map(extractCommitHeader)}),o=n.valid,a=n.errors;return a.length&&r.push([n.commit.header,a]),o}))?info("√  All commit messages in range valid."):(error("✘  Invalid commit message"),r.forEach((function(e){var t=tslib.__read(e,2),r=t[1];error.group(t[0]),printValidationErrors(r),error.groupEnd()})),process.exit(1))}function builder$3(e){return e.option("range",{description:"The range of commits to check, e.g. --range abc123..xyz456",demandOption:"  A range must be provided, e.g. --range abc123..xyz456",type:"string",requiresArg:!0})}function handler$3(e){var t=e.range;return tslib.__awaiter(this,void 0,void 0,(function(){return tslib.__generator(this,(function(e){return process.env.CI&&"false"===process.env.CI_PULL_REQUEST?(info("Since valid commit messages are enforced by PR linting on CI, we do not"),info("need to validate commit messages on CI runs on upstream branches."),info(),info("Skipping check of provided commit range"),[2]):(validateCommitRange(t),[2])}))}))}var ValidateRangeModule={handler:handler$3,builder:builder$3,command:"validate-range",describe:"Validate a range of commit messages"};function buildCommitMessage(){return tslib.__awaiter(this,void 0,void 0,(function(){var e,t,r;return tslib.__generator(this,(function(n){switch(n.label){case 0:return info("Just a few questions to start building the commit message!"),[4,promptForCommitMessageType()];case 1:return[4,promptForCommitMessageScopeForType(e=n.sent())];case 2:return t=n.sent(),[4,promptForCommitMessageSummary()];case 3:return r=n.sent(),[2,e.name+(t?"("+t+")":"")+": "+r+"\n\n"]}}))}))}function promptForCommitMessageType(){return tslib.__awaiter(this,void 0,void 0,(function(){var e;return tslib.__generator(this,(function(t){switch(t.label){case 0:return info("The type of change in the commit. Allows a reader to know the effect of the change,"),info("whether it brings a new feature, adds additional testing, documents the `project, etc."),[4,promptAutocomplete("Select a type for the commit:",Object.values(COMMIT_TYPES).map((function(e){var t=e.name;return{name:t+" - "+e.description,value:t,short:t}})))];case 1:return e=t.sent(),[2,COMMIT_TYPES[e]]}}))}))}function promptForCommitMessageScopeForType(e){return tslib.__awaiter(this,void 0,void 0,(function(){var t;return tslib.__generator(this,(function(r){switch(r.label){case 0:return e.scope===ScopeRequirement.Forbidden?(info("Skipping scope selection as the '"+e.name+"' type does not allow scopes"),[2,!1]):(t=getCommitMessageConfig(),info("The area of the repository the changes in this commit most affects."),[4,promptAutocomplete("Select a scope for the commit:",t.commitMessage.scopes,e.scope===ScopeRequirement.Optional?"<no scope>":"")]);case 1:return[2,r.sent()]}}))}))}function promptForCommitMessageSummary(){return tslib.__awaiter(this,void 0,void 0,(function(){return tslib.__generator(this,(function(e){switch(e.label){case 0:return info("Provide a short summary of what the changes in the commit do"),[4,promptInput("Provide a short summary of the commit")];case 1:return[2,e.sent()]}}))}))}var defaultCommitMessage="<type>(<scope>): <summary>\n\n# <Describe the motivation behind this change - explain WHY you are making this change. Wrap all\n#  lines at 100 characters.>\n\n";function runWizard(e){var t;return tslib.__awaiter(this,void 0,void 0,(function(){var r;return tslib.__generator(this,(function(n){switch(n.label){case 0:return(null===(t=getUserConfig().commitMessage)||void 0===t?void 0:t.disableWizard)?(debug("Skipping commit message wizard due to enabled `commitMessage.disableWizard` option in"),debug("user config."),process.exitCode=0,[2]):void 0!==e.source?(info("Skipping commit message wizard because the commit was created via '"+e.source+"' source"),process.exitCode=0,[2]):(fs.writeFileSync(e.filePath,defaultCommitMessage),[4,buildCommitMessage()]);case 1:return r=n.sent(),fs.writeFileSync(e.filePath,r),[2]}}))}))}function builder$4(e){return e.positional("filePath",{description:"The file path to write the generated commit message into",type:"string",demandOption:!0}).positional("source",{choices:["message","template","merge","squash","commit"],description:"The source of the commit message as described here: https://git-scm.com/docs/githooks#_prepare_commit_msg"}).positional("commitSha",{description:"The commit sha if source is set to `commit`",type:"string"})}function handler$4(e){return tslib.__awaiter(this,void 0,void 0,(function(){return tslib.__generator(this,(function(t){switch(t.label){case 0:return[4,runWizard(e)];case 1:return t.sent(),[2]}}))}))}var WizardModule={handler:handler$4,builder:builder$4,command:"wizard <filePath> [source] [commitSha]",describe:!1};function buildCommitMessageParser(e){return e.help().strict().command(RestoreCommitMessageModule).command(WizardModule).command(ValidateFileModule).command(ValidateRangeModule)}function allChangedFilesSince(e){void 0===e&&(e="HEAD");var t=gitOutputAsArray("git diff --name-only --diff-filter=d "+e),r=gitOutputAsArray("git ls-files --others --exclude-standard");return Array.from(new Set(tslib.__spread(t,r)))}function allStagedFiles(){return gitOutputAsArray("git diff --staged --name-only --diff-filter=ACM")}function allFiles(){return gitOutputAsArray("git ls-files")}function gitOutputAsArray(e){return exec(e,{cwd:getRepoBaseDir()}).split("\n").map((function(e){return e.trim()})).filter((function(e){return!!e}))}function getFormatConfig(){var e,t,r=[],n=getConfig();void 0===n.format&&r.push('No configuration defined for "format"');try{for(var i=tslib.__values(Object.entries(n.format)),o=i.next();!o.done;o=i.next()){var a=tslib.__read(o.value,2),s=a[0],u=a[1];switch(typeof u){case"boolean":break;case"object":checkFormatterConfig(s,u,r);break;default:r.push('"format.'+s+'" is not a boolean or Formatter object')}}}catch(t){e={error:t}}finally{try{o&&!o.done&&(t=i.return)&&t.call(i)}finally{if(e)throw e.error}}return assertNoErrors(r),n}function checkFormatterConfig(e,t,r){void 0===t.matchers&&r.push('Missing "format.'+e+'.matchers" value')}var Formatter=function(){function e(e){this.config=e}return e.prototype.commandFor=function(e){switch(e){case"check":return this.binaryFilePath+" "+this.actions.check.commandFlags;case"format":return this.binaryFilePath+" "+this.actions.format.commandFlags;default:throw Error("Unknown action type")}},e.prototype.callbackFor=function(e){switch(e){case"check":return this.actions.check.callback;case"format":return this.actions.format.callback;default:throw Error("Unknown action type")}},e.prototype.isEnabled=function(){return!!this.config[this.name]},e.prototype.getFileMatcher=function(){return this.getFileMatcherFromConfig()||this.defaultFileMatcher},e.prototype.getFileMatcherFromConfig=function(){var e=this.config[this.name];if("boolean"!=typeof e)return e.matchers},e}(),Buildifier=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.name="buildifier",t.binaryFilePath=path.join(getRepoBaseDir(),"node_modules/.bin/buildifier"),t.defaultFileMatcher=["**/*.bzl","**/BUILD.bazel","**/WORKSPACE","**/BUILD"],t.actions={check:{commandFlags:BAZEL_WARNING_FLAG+" --lint=warn --mode=check --format=json",callback:function(e,t,r){return 0!==t||!JSON.parse(r).success}},format:{commandFlags:BAZEL_WARNING_FLAG+" --lint=fix --mode=fix",callback:function(e,t,r,n){return 0!==t&&(error("Error running buildifier on: "+e),error(n),error(),!0)}}},t}return tslib.__extends(t,e),t}(Formatter),BAZEL_WARNING_FLAG="--warnings=attr-cfg,attr-license,attr-non-empty,attr-output-default,attr-single-file,constant-glob,ctx-args,depset-iteration,depset-union,dict-concatenation,duplicated-name,filetype,git-repository,http-archive,integer-division,load,load-on-top,native-build,native-package,output-group,package-name,package-on-top,positional-args,redefined-variable,repository-name,same-origin-load,string-iteration,unused-variable",ClangFormat=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.name="clang-format",t.binaryFilePath=path.join(getRepoBaseDir(),"node_modules/.bin/clang-format"),t.defaultFileMatcher=["**/*.{t,j}s"],t.actions={check:{commandFlags:"--Werror -n -style=file",callback:function(e,t){return 0!==t}},format:{commandFlags:"-i -style=file",callback:function(e,t,r,n){return 0!==t&&(error("Error running clang-format on: "+e),error(n),error(),!0)}}},t}return tslib.__extends(t,e),t}(Formatter);function getActiveFormatters(){var e=getFormatConfig().format;return[new Buildifier(e),new ClangFormat(e)].filter((function(e){return e.isEnabled()}))}var AVAILABLE_THREADS=Math.max(os.cpus().length-1,1);function runFormatterInParallel(e,t){return new Promise((function(r){var n,i,o=getActiveFormatters(),a=[],s=[],u=function(t){s.push.apply(s,tslib.__spread(multimatch.call(void 0,e,t.getFileMatcher(),{dot:!0}).map((function(e){return{formatter:t,file:e}}))))};try{for(var c=tslib.__values(o),l=c.next();!l.done;l=c.next())u(l.value)}catch(e){n={error:e}}finally{try{l&&!l.done&&(i=c.return)&&i.call(c)}finally{if(n)throw n.error}}if(0===s.length)return r(!1);switch(t){case"format":info("Formatting "+s.length+" file(s)");break;case"check":info("Checking format of "+s.length+" file(s)");break;default:throw Error('Invalid format action "'+t+'": allowed actions are "format" and "check"')}var h=new cliProgress.Bar({format:"[{bar}] ETA: {eta}s | {value}/{total} files",clearOnComplete:!0}),d=new Array(AVAILABLE_THREADS).fill(!1);h.start(s.length,0),d.forEach((function(e,n){return function e(n){var i=s.pop();if(void 0!==i){var o=i.file,u=i.formatter;shelljs.exec(u.commandFor(t)+" "+o,{async:!0,silent:!0},(function(i,c,l){if(u.callbackFor(t)(o,i,c,l)&&a.push(o),h.increment(1),s.length)return e(n);d[n]=!1,d.every((function(e){return!e}))&&(h.stop(),r(a))})),d[n]=!0}else d[n]=!1}(n)}))}))}function formatFiles(e){return tslib.__awaiter(this,void 0,void 0,(function(){var t;return tslib.__generator(this,(function(r){switch(r.label){case 0:return[4,runFormatterInParallel(e,"format")];case 1:return!1===(t=r.sent())&&(info("No files matched for formatting."),process.exit(0)),0!==t.length&&(error("Formatting failed, see errors above for more information."),process.exit(1)),info("√  Formatting complete."),process.exit(0),[2]}}))}))}function checkFiles(e){return tslib.__awaiter(this,void 0,void 0,(function(){var t,r,n,i,o,a;return tslib.__generator(this,(function(s){switch(s.label){case 0:return[4,runFormatterInParallel(e,"check")];case 1:if(!1===(t=s.sent())&&(info("No files matched for formatting check."),process.exit(0)),!t.length)return[3,7];info.group("\nThe following files are out of format:");try{for(r=tslib.__values(t),n=r.next();!n.done;n=r.next())info("  - "+n.value)}catch(e){o={error:e}}finally{try{n&&!n.done&&(a=r.return)&&a.call(r)}finally{if(o)throw o.error}}return info.groupEnd(),info(),i=!1,process.env.CI?[3,3]:[4,promptConfirm("Format the files now?",!0)];case 2:i=s.sent(),s.label=3;case 3:return i?[4,formatFiles(t)]:[3,5];case 4:return s.sent(),process.exit(0),[3,6];case 5:info(),info("To format the failing file run the following command:"),info("  yarn ng-dev format files "+t.join(" ")),process.exit(1),s.label=6;case 6:return[3,8];case 7:info("√  All files correctly formatted."),process.exit(0),s.label=8;case 8:return[2]}}))}))}function buildFormatParser(e){return e.help().strict().demandCommand().option("check",{type:"boolean",default:!!process.env.CI,description:"Run the formatter to check formatting rather than updating code format"}).command("all","Run the formatter on all files in the repository",(function(e){return e}),(function(e){(e.check?checkFiles:formatFiles)(allFiles())})).command("changed [shaOrRef]","Run the formatter on files changed since the provided sha/ref",(function(e){return e.positional("shaOrRef",{type:"string"})}),(function(e){(e.check?checkFiles:formatFiles)(allChangedFilesSince(e.shaOrRef||"master"))})).command("staged","Run the formatter on all staged files",(function(e){return e}),(function(e){(e.check?checkFiles:formatFiles)(allStagedFiles())})).command("files <files..>","Run the formatter on provided files",(function(e){return e.positional("files",{array:!0,type:"string"})}),(function(e){(e.check?checkFiles:formatFiles)(e.files)}))}function getPr(e,t,r){return tslib.__awaiter(this,void 0,void 0,(function(){var n,i,o,a;return tslib.__generator(this,(function(s){switch(s.label){case 0:return i=(n=r.remoteConfig).owner,o=n.name,a=typedGraphqlify.params({$number:"Int!",$owner:"String!",$name:"String!"},{repository:typedGraphqlify.params({owner:"$owner",name:"$name"},{pullRequest:typedGraphqlify.params({number:"$number"},e)})}),[4,r.github.graphql.query(a,{number:t,owner:i,name:o})];case 1:return[2,s.sent().repository.pullRequest]}}))}))}function getPendingPrs(e,t){return tslib.__awaiter(this,void 0,void 0,(function(){var r,n,i,o,a,s,u,c;return tslib.__generator(this,(function(l){switch(l.label){case 0:n=(r=t.remoteConfig).owner,i=r.name,o=typedGraphqlify.params({$first:"Int",$after:"String",$owner:"String!",$name:"String!"},{repository:typedGraphqlify.params({owner:"$owner",name:"$name"},{pullRequests:typedGraphqlify.params({first:"$first",after:"$after",states:"OPEN"},{nodes:[e],pageInfo:{hasNextPage:typedGraphqlify.types.boolean,endCursor:typedGraphqlify.types.string}})})}),s=!0,u=[],l.label=1;case 1:return s?[4,t.github.graphql.query(o,{after:a||null,first:100,owner:n,name:i})]:[3,3];case 2:return c=l.sent(),u.push.apply(u,tslib.__spread(c.repository.pullRequests.nodes)),s=c.repository.pullRequests.pageInfo.hasNextPage,a=c.repository.pullRequests.pageInfo.endCursor,[3,1];case 3:return[2,u]}}))}))}var PR_SCHEMA={state:typedGraphqlify.types.string,maintainerCanModify:typedGraphqlify.types.boolean,viewerDidAuthor:typedGraphqlify.types.boolean,headRefOid:typedGraphqlify.types.string,headRef:{name:typedGraphqlify.types.string,repository:{url:typedGraphqlify.types.string,nameWithOwner:typedGraphqlify.types.string}},baseRef:{name:typedGraphqlify.types.string,repository:{url:typedGraphqlify.types.string,nameWithOwner:typedGraphqlify.types.string}}},UnexpectedLocalChangesError=function(e){function t(r){var n=e.call(this,r)||this;return Object.setPrototypeOf(n,t.prototype),n}return tslib.__extends(t,e),t}(Error),MaintainerModifyAccessError=function(e){function t(r){var n=e.call(this,r)||this;return Object.setPrototypeOf(n,t.prototype),n}return tslib.__extends(t,e),t}(Error);function checkOutPullRequestLocally(e,t,r){return void 0===r&&(r={}),tslib.__awaiter(this,void 0,void 0,(function(){var n,i,o,a,s,u,c;return tslib.__generator(this,(function(l){switch(l.label){case 0:if((n=new GitClient(t)).hasLocalChanges())throw new UnexpectedLocalChangesError("Unable to checkout PR due to uncommitted changes.");return i=n.getCurrentBranchOrRevision(),[4,getPr(PR_SCHEMA,e,n)];case 1:if(o=l.sent(),s=o.headRef.repository.nameWithOwner+":"+(a=o.headRef.name),u=addTokenToGitHttpsUrl(o.headRef.repository.url,t),c="--force-with-lease="+a+":"+o.headRefOid,!o.maintainerCanModify&&!o.viewerDidAuthor&&!r.allowIfMaintainerCannotModify)throw new MaintainerModifyAccessError("PR is not set to allow maintainers to modify the PR");try{info("Checking out PR #"+e+" from "+s),n.run(["fetch",u,a]),n.run(["checkout","--detach","FETCH_HEAD"])}catch(e){throw n.checkout(i,!0),e}return[2,{pushToUpstream:function(){return n.run(["push",u,"HEAD:"+a,c]),!0},resetGitState:function(){return n.checkout(i,!0)}}]}}))}))}function builder$5(e){return addGithubTokenOption(e).positional("prNumber",{type:"number",demandOption:!0})}function handler$5(e){var t=e.prNumber,r=e.githubToken;return tslib.__awaiter(this,void 0,void 0,(function(){return tslib.__generator(this,(function(e){switch(e.label){case 0:return[4,checkOutPullRequestLocally(t,r,{allowIfMaintainerCannotModify:!0,branchName:"pr-"+t})];case 1:return e.sent(),[2]}}))}))}var CheckoutCommandModule={handler:handler$5,builder:builder$5,command:"checkout <pr-number>",describe:"Checkout a PR from the upstream repo"},PR_SCHEMA$1={headRef:{name:typedGraphqlify.types.string,repository:{url:typedGraphqlify.types.string,nameWithOwner:typedGraphqlify.types.string}},baseRef:{name:typedGraphqlify.types.string,repository:{url:typedGraphqlify.types.string,nameWithOwner:typedGraphqlify.types.string}},updatedAt:typedGraphqlify.types.string,number:typedGraphqlify.types.number,mergeable:typedGraphqlify.types.string,title:typedGraphqlify.types.string};function processPr(e){return tslib.__assign(tslib.__assign({},e),{updatedAt:new Date(e.updatedAt).getTime()})}var tempWorkingBranch="__NgDevRepoBaseAfterChange__";function discoverNewConflictsForPr(e,t,r){return void 0===r&&(r=getConfig()),tslib.__awaiter(this,void 0,void 0,(function(){var r,n,i,o,a,s,u,c,l,h,d,f,p,g,m,v;return tslib.__generator(this,(function(b){switch(b.label){case 0:return(r=new GitClient).hasLocalChanges()&&(error("Cannot run with local changes. Please make sure there are no local changes."),process.exit(1)),n=r.getCurrentBranchOrRevision(),i=new cliProgress.Bar({format:"[{bar}] ETA: {eta}s | {value}/{total}"}),o=[],info("Requesting pending PRs from Github"),[4,getPendingPrs(PR_SCHEMA$1,r)];case 1:a=b.sent().map(processPr),void 0===(s=a.find((function(t){return t.number===e})))&&(error("The request PR, #"+e+" was not found as a pending PR on github, please confirm"),error("the PR number is correct and is an open PR"),process.exit(1)),u=a.filter((function(e){return e.baseRef.name===s.baseRef.name&&"CONFLICTING"!==e.mergeable&&e.updatedAt>=t})),info("Retrieved "+a.length+" total pending PRs"),info("Checking "+u.length+" PRs for conflicts after a merge of #"+e),exec("git fetch "+s.headRef.repository.url+" "+s.headRef.name),exec("git checkout -B "+tempWorkingBranch+" FETCH_HEAD"),exec("git fetch "+s.baseRef.repository.url+" "+s.baseRef.name),exec("git rebase FETCH_HEAD").code&&(error("The requested PR currently has conflicts"),cleanUpGitState(n),process.exit(1)),i.start(u.length,0);try{for(c=tslib.__values(u),l=c.next();!l.done;l=c.next())exec("git fetch "+(f=l.value).headRef.repository.url+" "+f.headRef.name),exec("git checkout --detach FETCH_HEAD"),0!==exec("git rebase "+tempWorkingBranch).code&&o.push(f),exec("git rebase --abort"),i.increment(1)}catch(e){p={error:e}}finally{try{l&&!l.done&&(g=c.return)&&g.call(c)}finally{if(p)throw p.error}}i.stop(),info(),info("Result:"),cleanUpGitState(n),0===o.length&&(info("No new conflicting PRs found after #"+e+" merging"),process.exit(0)),error.group(o.length+" PR(s) which conflict(s) after #"+e+" merges:");try{for(h=tslib.__values(o),d=h.next();!d.done;d=h.next())error("  - #"+(f=d.value).number+": "+f.title)}catch(e){m={error:e}}finally{try{d&&!d.done&&(v=h.return)&&v.call(h)}finally{if(m)throw m.error}}return error.groupEnd(),process.exit(1),[2]}}))}))}function cleanUpGitState(e){exec("git rebase --abort"),exec("git reset --hard"),exec("git checkout "+e),exec("git branch -D "+tempWorkingBranch)}function buildDiscoverNewConflictsCommand(e){return e.option("date",{description:"Only consider PRs updated since provided date",defaultDescription:"30 days ago",coerce:function(e){return"number"==typeof e?e:Date.parse(e)},default:getThirtyDaysAgoDate()}).positional("pr-number",{demandOption:!0,type:"number"})}function handleDiscoverNewConflictsCommand(e){var t=e["pr-number"],r=e.date;return tslib.__awaiter(this,void 0,void 0,(function(){return tslib.__generator(this,(function(e){switch(e.label){case 0:return isNaN(r)&&(error("Unable to parse the value provided via --date flag"),process.exit(1)),[4,discoverNewConflictsForPr(t,r)];case 1:return e.sent(),[2]}}))}))}function getThirtyDaysAgoDate(){var e=new Date;return e.setHours(0,0,0,0),e.setDate(e.getDate()-30),e.getTime()}function loadAndValidateConfig(e,t){return tslib.__awaiter(this,void 0,void 0,(function(){var r,n;return tslib.__generator(this,(function(i){switch(i.label){case 0:return void 0===e.merge?[2,{errors:["No merge configuration found. Set the `merge` configuration."]}]:"function"!=typeof e.merge?[2,{errors:["Expected merge configuration to be defined lazily through a function."]}]:[4,e.merge(t)];case 1:return r=i.sent(),(n=validateMergeConfig(r)).length?[2,{errors:n}]:[2,{config:r}]}}))}))}function validateMergeConfig(e){var t=[];return e.labels?Array.isArray(e.labels)||t.push("Label configuration needs to be an array."):t.push("No label configuration."),e.claSignedLabel||t.push("No CLA signed label configured."),e.mergeReadyLabel||t.push("No merge ready label configured."),void 0===e.githubApiMerge&&t.push("No explicit choice of merge strategy. Please set `githubApiMerge`."),t}var PullRequestFailure=function(){function e(e,t){void 0===t&&(t=!1),this.message=e,this.nonFatal=t}return e.claUnsigned=function(){return new this("CLA has not been signed. Please make sure the PR author has signed the CLA.")},e.failingCiJobs=function(){return new this("Failing CI jobs.",!0)},e.pendingCiJobs=function(){return new this("Pending CI jobs.",!0)},e.notMergeReady=function(){return new this("Not marked as merge ready.")},e.noTargetLabel=function(){return new this("No target branch could be determined. Please ensure a target label is set.")},e.mismatchingTargetBranch=function(e){return new this("Pull request is set to wrong base branch. Please update the PR in the Github UI to one of the following branches: "+e.join(", ")+".")},e.unsatisfiedBaseSha=function(){return new this("Pull request has not been rebased recently and could be bypassing CI checks. Please rebase the PR.")},e.mergeConflicts=function(e){return new this("Could not merge pull request into the following branches due to merge conflicts: "+e.join(", ")+". Please rebase the PR or update the target label.")},e.unknownMergeError=function(){return new this("Unknown merge error occurred. Please see console output above for debugging.")},e.unableToFixupCommitMessageSquashOnly=function(){return new this("Unable to fixup commit message of pull request. Commit message can only be modified if the PR is merged using squash.")},e.notFound=function(){return new this("Pull request could not be found upstream.")},e.insufficientPermissionsToMerge=function(e){return void 0===e&&(e="Insufficient Github API permissions to merge pull request. Please ensure that your auth token has write access."),new this(e)},e}();function getCaretakerNotePromptMessage(e){return red("Pull request has a caretaker note applied. Please make sure you read it.")+"\nQuick link to PR: "+e.url}function matchesPattern(e,t){return"string"==typeof t?e===t:t.test(e)}var InvalidTargetBranchError=function InvalidTargetBranchError(e){this.failureMessage=e},InvalidTargetLabelError=function InvalidTargetLabelError(e){this.failureMessage=e};function getTargetLabelFromPullRequest(e,t){var r,n,i=function(t){var r=e.labels.find((function(e){return matchesPattern(t,e.pattern)}));if(void 0!==r)return{value:r}};try{for(var o=tslib.__values(t),a=o.next();!a.done;a=o.next()){var s=i(a.value);if("object"==typeof s)return s.value}}catch(e){r={error:e}}finally{try{a&&!a.done&&(n=o.return)&&n.call(o)}finally{if(r)throw r.error}}return null}function getBranchesFromTargetLabel(e,t){return tslib.__awaiter(this,void 0,void 0,(function(){var r;return tslib.__generator(this,(function(n){switch(n.label){case 0:return"function"!=typeof e.branches?[3,2]:[4,e.branches(t)];case 1:return r=n.sent(),[3,4];case 2:return[4,e.branches];case 3:r=n.sent(),n.label=4;case 4:return[2,r]}}))}))}function loadAndValidatePullRequest(e,t,r){var n=e.git,i=e.config;return void 0===r&&(r=!1),tslib.__awaiter(this,void 0,void 0,(function(){var e,o,a,s,u,c,l,h,d,f;return tslib.__generator(this,(function(p){switch(p.label){case 0:return[4,fetchPullRequestFromGithub(n,t)];case 1:return null===(e=p.sent())?[2,PullRequestFailure.notFound()]:(o=e.labels.map((function(e){return e.name}))).some((function(e){return matchesPattern(e,i.mergeReadyLabel)}))?o.some((function(e){return matchesPattern(e,i.claSignedLabel)}))?null===(a=getTargetLabelFromPullRequest(i,o))?[2,PullRequestFailure.noTargetLabel()]:[4,n.github.repos.getCombinedStatusForRef(tslib.__assign(tslib.__assign({},n.remoteParams),{ref:e.head.sha}))]:[2,PullRequestFailure.claUnsigned()]:[2,PullRequestFailure.notMergeReady()];case 2:if("failure"===(s=p.sent().data.state)&&!r)return[2,PullRequestFailure.failingCiJobs()];if("pending"===s&&!r)return[2,PullRequestFailure.pendingCiJobs()];u=e.base.ref,c=i.requiredBaseCommits&&i.requiredBaseCommits[u],l=!!i.commitMessageFixupLabel&&o.some((function(e){return matchesPattern(e,i.commitMessageFixupLabel)})),h=!!i.caretakerNoteLabel&&o.some((function(e){return matchesPattern(e,i.caretakerNoteLabel)})),p.label=3;case 3:return p.trys.push([3,5,,6]),[4,getBranchesFromTargetLabel(a,u)];case 4:return d=p.sent(),[3,6];case 5:if((f=p.sent())instanceof InvalidTargetBranchError||f instanceof InvalidTargetLabelError)return[2,new PullRequestFailure(f.failureMessage)];throw f;case 6:return[2,{url:e.html_url,prNumber:t,labels:o,requiredBaseSha:c,githubTargetBranch:u,needsCommitMessageFixup:l,hasCaretakerNote:h,targetBranches:d,title:e.title,commitCount:e.commits}]}}))}))}function fetchPullRequestFromGithub(e,t){return tslib.__awaiter(this,void 0,void 0,(function(){var r;return tslib.__generator(this,(function(n){switch(n.label){case 0:return n.trys.push([0,2,,3]),[4,e.github.pulls.get(tslib.__assign(tslib.__assign({},e.remoteParams),{pull_number:t}))];case 1:return[2,n.sent().data];case 2:if(404===(r=n.sent()).status)return[2,null];throw r;case 3:return[2]}}))}))}function isPullRequest(e){return void 0!==e.targetBranches}var TEMP_PR_HEAD_BRANCH="merge_pr_head",MergeStrategy=function(){function e(e){this.git=e}return e.prototype.prepare=function(e){return tslib.__awaiter(this,void 0,void 0,(function(){return tslib.__generator(this,(function(t){return this.fetchTargetBranches(e.targetBranches,"pull/"+e.prNumber+"/head:"+TEMP_PR_HEAD_BRANCH),[2]}))}))},e.prototype.cleanup=function(e){return tslib.__awaiter(this,void 0,void 0,(function(){var t=this;return tslib.__generator(this,(function(r){return e.targetBranches.forEach((function(e){return t.git.run(["branch","-D",t.getLocalTargetBranchName(e)])})),this.git.run(["branch","-D",TEMP_PR_HEAD_BRANCH]),[2]}))}))},e.prototype.getPullRequestRevisionRange=function(e){return this.getPullRequestBaseRevision(e)+".."+TEMP_PR_HEAD_BRANCH},e.prototype.getPullRequestBaseRevision=function(e){return TEMP_PR_HEAD_BRANCH+"~"+e.commitCount},e.prototype.getLocalTargetBranchName=function(e){return"merge_pr_target_"+e.replace(/\//g,"_")},e.prototype.cherryPickIntoTargetBranches=function(e,t,r){var n,i;void 0===r&&(r={});var o=[e],a=[];r.dryRun&&o.push("--no-commit"),r.linkToOriginalCommits&&o.push("-x");try{for(var s=tslib.__values(t),u=s.next();!u.done;u=s.next()){var c=u.value,l=this.getLocalTargetBranchName(c);this.git.run(["checkout",l]),0!==this.git.runGraceful(tslib.__spread(["cherry-pick"],o)).status&&(this.git.runGraceful(["cherry-pick","--abort"]),a.push(c)),r.dryRun&&this.git.run(["reset","--hard","HEAD"])}}catch(e){n={error:e}}finally{try{u&&!u.done&&(i=s.return)&&i.call(s)}finally{if(n)throw n.error}}return a},e.prototype.fetchTargetBranches=function(e){for(var t=this,r=[],n=1;n<arguments.length;n++)r[n-1]=arguments[n];var i=e.map((function(e){return"refs/heads/"+e+":"+t.getLocalTargetBranchName(e)}));this.git.run(tslib.__spread(["fetch","-f",this.git.repoGitUrl],i,r))},e.prototype.pushTargetBranchesUpstream=function(e){var t=this,r=e.map((function(e){return t.getLocalTargetBranchName(e)+":refs/heads/"+e}));this.git.run(tslib.__spread(["push",this.git.repoGitUrl],r))},e}(),COMMIT_HEADER_SEPARATOR="\n\n",GithubApiMergeStrategy=function(e){function t(t,r){var n=e.call(this,t)||this;return n._config=r,n}return tslib.__extends(t,e),t.prototype.merge=function(e){return tslib.__awaiter(this,void 0,void 0,(function(){var t,r,n,i,o,a,s,u,c,l,h,d,f,p;return tslib.__generator(this,(function(g){switch(g.label){case 0:return t=e.githubTargetBranch,r=e.prNumber,i=e.requiredBaseSha,o=e.needsCommitMessageFixup,(n=e.targetBranches).every((function(e){return e!==t}))?[2,PullRequestFailure.mismatchingTargetBranch(n)]:i&&!this.git.hasCommit(TEMP_PR_HEAD_BRANCH,i)?[2,PullRequestFailure.unsatisfiedBaseSha()]:(a=this._getMergeActionFromPullRequest(e),s=n.filter((function(e){return e!==t})),[4,this._checkMergability(e,s)]);case 1:return null!==(u=g.sent())?[2,u]:(c=tslib.__assign({pull_number:r,merge_method:a},this.git.remoteParams),o?"squash"!==a?[2,PullRequestFailure.unableToFixupCommitMessageSquashOnly()]:[4,this._promptCommitMessageEdit(e,c)]:[3,3]);case 2:g.sent(),g.label=3;case 3:return g.trys.push([3,5,,6]),[4,this.git.github.pulls.merge(c)];case 4:return d=g.sent(),l=d.status,h=d.data.sha,[3,6];case 5:if(403===(f=g.sent()).status||404===f.status)return[2,PullRequestFailure.insufficientPermissionsToMerge()];throw f;case 6:return 405===l?[2,PullRequestFailure.mergeConflicts([t])]:200!==l?[2,PullRequestFailure.unknownMergeError()]:s.length?(this.fetchTargetBranches([t]),[4,this.cherryPickIntoTargetBranches(h+"~"+("squash"===a?1:e.commitCount)+".."+h,s,{linkToOriginalCommits:!0})]):[2,null];case 7:return(p=g.sent()).length?[2,PullRequestFailure.mergeConflicts(p)]:(this.pushTargetBranchesUpstream(s),[2,null])}}))}))},t.prototype._promptCommitMessageEdit=function(e,t){return tslib.__awaiter(this,void 0,void 0,(function(){var r,n,i,o,a;return tslib.__generator(this,(function(s){switch(s.label){case 0:return[4,this._getDefaultSquashCommitMessage(e)];case 1:return r=s.sent(),[4,inquirer.prompt({type:"editor",name:"result",message:"Please update the commit message",default:r})];case 2:return n=s.sent().result,i=tslib.__read(n.split(COMMIT_HEADER_SEPARATOR)),o=i[0],a=i.slice(1),t.commit_title=o+" (#"+e.prNumber+")",t.commit_message=a.join(COMMIT_HEADER_SEPARATOR),[2]}}))}))},t.prototype._getDefaultSquashCommitMessage=function(e){return tslib.__awaiter(this,void 0,void 0,(function(){var t,r,n;return tslib.__generator(this,(function(i){switch(i.label){case 0:return[4,this._getPullRequestCommitMessages(e)];case 1:return t=i.sent().map((function(e){return{message:e,parsed:parseCommitMessage(e)}})),r=""+e.title+COMMIT_HEADER_SEPARATOR,t.length<=1?[2,""+r+t[0].parsed.body]:(n=t.map((function(e){return"* "+e.message})).join(COMMIT_HEADER_SEPARATOR),[2,""+r+n])}}))}))},t.prototype._getPullRequestCommitMessages=function(e){var t=e.prNumber;return tslib.__awaiter(this,void 0,void 0,(function(){var e;return tslib.__generator(this,(function(r){switch(r.label){case 0:return e=this.git.github.pulls.listCommits.endpoint.merge(tslib.__assign(tslib.__assign({},this.git.remoteParams),{pull_number:t})),[4,this.git.github.paginate(e)];case 1:return[2,r.sent().map((function(e){return e.commit.message}))]}}))}))},t.prototype._checkMergability=function(e,t){return tslib.__awaiter(this,void 0,void 0,(function(){var r,n;return tslib.__generator(this,(function(i){return r=this.getPullRequestRevisionRange(e),(n=this.cherryPickIntoTargetBranches(r,t,{dryRun:!0})).length?[2,PullRequestFailure.mergeConflicts(n)]:[2,null]}))}))},t.prototype._getMergeActionFromPullRequest=function(e){var t=e.labels;if(this._config.labels){var r=this._config.labels.find((function(e){var r=e.pattern;return t.some((function(e){return matchesPattern(e,r)}))}));if(void 0!==r)return r.method}return this._config.default},t}(MergeStrategy),MSG_FILTER_SCRIPT=path.join(__dirname,"./commit-message-filter.js").replace(/\\/g,"/"),AutosquashMergeStrategy=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return tslib.__extends(t,e),t.prototype.merge=function(e){return tslib.__awaiter(this,void 0,void 0,(function(){var t,r,n,i,o,a,s,u,c;return tslib.__generator(this,(function(l){return t=e.prNumber,r=e.targetBranches,i=e.needsCommitMessageFixup,(n=e.requiredBaseSha)&&!this.git.hasCommit(TEMP_PR_HEAD_BRANCH,n)?[2,PullRequestFailure.unsatisfiedBaseSha()]:(o=this.git.run(["rev-parse",this.getPullRequestBaseRevision(e)]).stdout.trim(),a=o+".."+TEMP_PR_HEAD_BRANCH,s=this.git.getCurrentBranchOrRevision(),u=i?void 0:tslib.__assign(tslib.__assign({},process.env),{GIT_SEQUENCE_EDITOR:"true"}),this.git.run(["rebase","--interactive","--autosquash",o,TEMP_PR_HEAD_BRANCH],{stdio:"inherit",env:u}),this.git.run(["checkout","-f",s]),this.git.run(["filter-branch","-f","--msg-filter",MSG_FILTER_SCRIPT+" "+t,a]),(c=this.cherryPickIntoTargetBranches(a,r)).length?[2,PullRequestFailure.mergeConflicts(c)]:(this.pushTargetBranchesUpstream(r),[2,null]))}))}))},t}(MergeStrategy),PullRequestMergeTask=function(){function e(e,t){this.config=e,this.git=t}return e.prototype.merge=function(e,t){return void 0===t&&(t=!1),tslib.__awaiter(this,void 0,void 0,(function(){var r,n,i,o,a,s,u,c=this;return tslib.__generator(this,(function(l){switch(l.label){case 0:return[4,this.git.hasOauthScopes((function(e,t){e.includes("repo")||(c.config.remote.private?t.push("repo"):e.includes("public_repo")||t.push("public_repo"))}))];case 1:return!0!==(r=l.sent())?[2,{status:5,failure:PullRequestFailure.insufficientPermissionsToMerge(r.error)}]:this.git.hasUncommittedChanges()?[2,{status:1}]:[4,loadAndValidatePullRequest(this,e,t)];case 2:return isPullRequest(n=l.sent())?(i=n.hasCaretakerNote)?[4,promptConfirm(getCaretakerNotePromptMessage(n)+"\nDo you want to proceed merging?")]:[3,4]:[2,{status:3,failure:n}];case 3:i=!l.sent(),l.label=4;case 4:if(i)return[2,{status:4}];o=this.config.githubApiMerge?new GithubApiMergeStrategy(this.git,this.config.githubApiMerge):new AutosquashMergeStrategy(this.git),a=null,l.label=5;case 5:return l.trys.push([5,9,10,11]),a=this.git.getCurrentBranchOrRevision(),[4,o.prepare(n)];case 6:return l.sent(),[4,o.merge(n)];case 7:return null!==(s=l.sent())?[2,{status:3,failure:s}]:(this.git.run(["checkout","-f",a]),[4,o.cleanup(n)]);case 8:return l.sent(),[2,{status:2}];case 9:if((u=l.sent())instanceof GitCommandError)return[2,{status:0}];throw u;case 10:return null!==a&&this.git.runGraceful(["checkout","-f",a]),[7];case 11:return[2]}}))}))},e}();function mergePullRequest(e,t,r,n){return void 0===r&&(r=getRepoBaseDir()),tslib.__awaiter(this,void 0,void 0,(function(){function i(t){return tslib.__awaiter(this,void 0,void 0,(function(){var r;return tslib.__generator(this,(function(n){switch(n.label){case 0:return n.trys.push([0,3,,4]),[4,s.merge(e,t)];case 1:return[4,a(n.sent(),t)];case 2:return[2,n.sent()];case 3:throw(r=n.sent())instanceof GithubApiRequestError&&401===r.status&&(error(red("Github API request failed. "+r.message)),error(yellow("Please ensure that your provided token is valid.")),error(yellow("You can generate a token here: "+GITHUB_TOKEN_GENERATE_URL)),process.exit(1)),r;case 4:return[2]}}))}))}function o(){return tslib.__awaiter(this,void 0,void 0,(function(){return tslib.__generator(this,(function(e){switch(e.label){case 0:return[4,promptConfirm("Do you want to forcibly proceed with merging?")];case 1:return e.sent()?[2,i(!0)]:[2,!1]}}))}))}function a(t,r){return void 0===r&&(r=!1),tslib.__awaiter(this,void 0,void 0,(function(){var n,i,a;return tslib.__generator(this,(function(s){switch(s.label){case 0:switch(a=(n=t.failure)&&n.nonFatal,i=t.status){case 2:return[3,1];case 1:return[3,2];case 0:return[3,3];case 5:return[3,4];case 4:return[3,5];case 3:return[3,6]}return[3,9];case 1:return info(green("Successfully merged the pull request: #"+e)),[2,!0];case 2:return error(red("Local working repository not clean. Please make sure there are no uncommitted changes.")),[2,!1];case 3:return error(red("An unknown Git error has been thrown. Please check the output above for details.")),[2,!1];case 4:return error(red("An error related to interacting with Github has been discovered.")),error(n.message),[2,!1];case 5:return info("Merge of pull request has been aborted manually: #"+e),[2,!0];case 6:return error(yellow("Could not merge the specified pull request.")),error(red(n.message)),!a||r?[3,8]:(info(),info(yellow("The pull request above failed due to non-critical errors.")),info(yellow("This error can be forcibly ignored if desired.")),[4,o()]);case 7:return[2,s.sent()];case 8:return[2,!1];case 9:throw Error("Unexpected merge result: "+i)}}))}))}var s;return tslib.__generator(this,(function(e){switch(e.label){case 0:return process.env.HUSKY_SKIP_HOOKS="1",[4,createPullRequestMergeTask(t,r,n)];case 1:return s=e.sent(),[4,i(!1)];case 2:return e.sent()||process.exit(1),[2]}}))}))}function createPullRequestMergeTask(e,t,r){return tslib.__awaiter(this,void 0,void 0,(function(){var n,i,o,a,s,u;return tslib.__generator(this,(function(c){switch(c.label){case 0:return void 0!==r?(n=new GitClient(e,{github:r.remote},t),[2,new PullRequestMergeTask(r,n)]):(i=getConfig(),o=new GitClient(e,i,t),[4,loadAndValidateConfig(i,o.github)]);case 1:return a=c.sent(),s=a.config,(u=a.errors)&&(error(red("Invalid merge configuration:")),u.forEach((function(e){return error(yellow("  -  "+e))})),process.exit(1)),s.remote=i.github,[2,new PullRequestMergeTask(s,o)]}}))}))}function buildMergeCommand(e){return addGithubTokenOption(e).help().strict().positional("pr-number",{demandOption:!0,type:"number"})}function handleMergeCommand(e){var t=e["pr-number"],r=e.githubToken;return tslib.__awaiter(this,void 0,void 0,(function(){return tslib.__generator(this,(function(e){switch(e.label){case 0:return[4,mergePullRequest(t,r)];case 1:return e.sent(),[2]}}))}))}var PR_SCHEMA$2={state:typedGraphqlify.types.string,maintainerCanModify:typedGraphqlify.types.boolean,viewerDidAuthor:typedGraphqlify.types.boolean,headRefOid:typedGraphqlify.types.string,headRef:{name:typedGraphqlify.types.string,repository:{url:typedGraphqlify.types.string,nameWithOwner:typedGraphqlify.types.string}},baseRef:{name:typedGraphqlify.types.string,repository:{url:typedGraphqlify.types.string,nameWithOwner:typedGraphqlify.types.string}}};function rebasePr(e,t,r){return void 0===r&&(r=getConfig()),tslib.__awaiter(this,void 0,void 0,(function(){var r,n,i,o,a,s,u,c,l,h,d;return tslib.__generator(this,(function(f){switch(f.label){case 0:return(r=new GitClient(t)).hasLocalChanges()&&(error("Cannot perform rebase of PR with local changes."),process.exit(1)),n=r.getCurrentBranchOrRevision(),[4,getPr(PR_SCHEMA$2,e,r)];case 1:i=f.sent(),s=i.headRef.repository.nameWithOwner+":"+(o=i.headRef.name),u=i.baseRef.repository.nameWithOwner+":"+(a=i.baseRef.name),c=addTokenToGitHttpsUrl(i.headRef.repository.url,t),l=addTokenToGitHttpsUrl(i.baseRef.repository.url,t),h="--force-with-lease="+o+":"+i.headRefOid,i.maintainerCanModify||i.viewerDidAuthor||(error("Cannot rebase as you did not author the PR and the PR does not allow maintainersto modify the PR"),process.exit(1));try{info("Checking out PR #"+e+" from "+s),r.run(["fetch",c,o]),r.run(["checkout","--detach","FETCH_HEAD"]),info("Fetching "+u+" to rebase #"+e+" on"),r.run(["fetch",l,a]),info("Attempting to rebase PR #"+e+" on "+u),0===r.runGraceful(["rebase","FETCH_HEAD"]).status&&(info("Rebase was able to complete automatically without conflicts"),info("Pushing rebased PR #"+e+" to "+s),r.run(["push",c,"HEAD:"+o,h]),info("Rebased and updated PR #"+e),r.checkout(n,!0),process.exit(0))}catch(e){error(e.message),r.checkout(n,!0),process.exit(1)}return info("Rebase was unable to complete automatically without conflicts."),(d=void 0===process.env.CI)?[4,promptConfirm("Manually complete rebase?")]:[3,3];case 2:d=f.sent(),f.label=3;case 3:return d?(info("After manually completing rebase, run the following command to update PR #"+e+":"),info(" $ git push "+i.headRef.repository.url+" HEAD:"+o+" "+h),info(),info("To abort the rebase and return to the state of the repository before this command"),info("run the following command:"),info(" $ git rebase --abort && git reset --hard && git checkout "+n),process.exit(1)):info("Cleaning up git state, and restoring previous state."),r.checkout(n,!0),process.exit(1),[2]}}))}))}function buildRebaseCommand(e){return addGithubTokenOption(e).positional("prNumber",{type:"number",demandOption:!0})}function handleRebaseCommand(e){var t=e.prNumber,r=e.githubToken;return tslib.__awaiter(this,void 0,void 0,(function(){return tslib.__generator(this,(function(e){switch(e.label){case 0:return[4,rebasePr(t,r)];case 1:return e.sent(),[2]}}))}))}function buildPrParser(e){return e.help().strict().demandCommand().command("merge <pr-number>","Merge pull requests",buildMergeCommand,handleMergeCommand).command("discover-new-conflicts <pr-number>","Check if a pending PR causes new conflicts for other pending PRs",buildDiscoverNewConflictsCommand,handleDiscoverNewConflictsCommand).command("rebase <pr-number>","Rebase a pending PR and push the rebased commits back to Github",buildRebaseCommand,handleRebaseCommand).command(CheckoutCommandModule)}function logGroup(e,t,r){void 0===r&&(r=info);var n=e[t];r.group("["+e.groupName+"]"),n.length&&(n.forEach((function(e){var n=e.matchedFiles.size;r("unverifiableConditions"===t?""+e.expression:n+" "+(1===n?"match":"matches")+" - "+e.expression)})),r.groupEnd())}function logHeader(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var r=80,n=r-2,i=e.join(" ").substr(0,n),o=Math.ceil((n-i.length)/2),a=n-o-i.length,s=function(e,t){return t.repeat(e)};info("┌"+s(n,"─")+"┐"),info("│"+s(o," ")+i+s(a," ")+"│"),info("└"+s(n,"─")+"┘")}var patternCache=new Map;function getOrCreateGlob(e){if(patternCache.has(e))return patternCache.get(e);var t=new minimatch.Minimatch(e,{dot:!0});return patternCache.set(e,t),t}var PullApproveGroupStateDependencyError=function(e){function t(r){var n=e.call(this,r)||this;return Object.setPrototypeOf(n,t.prototype),n.name=t.name,n}return tslib.__extends(t,e),t}(Error),PullApproveStringArray=function(e){function t(){for(var r=[],n=0;n<arguments.length;n++)r[n]=arguments[n];var i=e.apply(this,tslib.__spread(r))||this;return Object.setPrototypeOf(i,t.prototype),i}return tslib.__extends(t,e),t.prototype.include=function(e){return new(t.bind.apply(t,tslib.__spread([void 0],this.filter((function(t){return getOrCreateGlob(e).match(t)})))))},t.prototype.exclude=function(e){return new(t.bind.apply(t,tslib.__spread([void 0],this.filter((function(t){return!getOrCreateGlob(e).match(t)})))))},t}(Array),PullApproveGroupArray=function(e){function t(){for(var r=[],n=0;n<arguments.length;n++)r[n]=arguments[n];var i=e.apply(this,tslib.__spread(r))||this;return Object.setPrototypeOf(i,t.prototype),i}return tslib.__extends(t,e),t.prototype.include=function(e){return new(t.bind.apply(t,tslib.__spread([void 0],this.filter((function(t){return t.groupName.match(e)})))))},t.prototype.exclude=function(e){return new(t.bind.apply(t,tslib.__spread([void 0],this.filter((function(t){return t.groupName.match(e)})))))},Object.defineProperty(t.prototype,"pending",{get:function(){throw new PullApproveGroupStateDependencyError},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"active",{get:function(){throw new PullApproveGroupStateDependencyError},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"inactive",{get:function(){throw new PullApproveGroupStateDependencyError},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"rejected",{get:function(){throw new PullApproveGroupStateDependencyError},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"names",{get:function(){return this.map((function(e){return e.groupName}))},enumerable:!1,configurable:!0}),t}(Array),conditionContext={len:function(e){return e.length},contains_any_globs:function(e,t){return e.some((function(e){return t.some((function(t){return getOrCreateGlob(t).match(e)}))}))}};function convertConditionToFunction(e){var t=new(Function.bind.apply(Function,tslib.__spread([void 0,"files","groups"],Object.keys(conditionContext),["\n    return ("+transformExpressionToJs(e)+");\n  "])));return function(e,r){var n=t.apply(void 0,tslib.__spread([new(PullApproveStringArray.bind.apply(PullApproveStringArray,tslib.__spread([void 0],e))),new(PullApproveGroupArray.bind.apply(PullApproveGroupArray,tslib.__spread([void 0],r)))],Object.values(conditionContext)));return Array.isArray(n)?0!==n.length:!!n}}function transformExpressionToJs(e){return e.replace(/not\s+/g,"!")}var GLOBAL_APPROVAL_CONDITION_REGEX=/^"global-(docs-)?approvers" not in groups.approved$/,FALLBACK_GROUP_NAME="fallback",PullApproveGroup=function(){function e(e,t,r){void 0===r&&(r=[]),this.groupName=e,this.precedingGroups=r,this.conditions=[],this._captureConditions(t)}return e.prototype._captureConditions=function(e){var t=this;if(e.conditions&&this.groupName!==FALLBACK_GROUP_NAME)return e.conditions.forEach((function(e){var r=e.trim();if(!r.match(GLOBAL_APPROVAL_CONDITION_REGEX))try{t.conditions.push({expression:r,checkFn:convertConditionToFunction(r),matchedFiles:new Set,unverifiable:!1})}catch(e){error("Could not parse condition in group: "+t.groupName),error(" - "+r),error("Error:"),error(e.message),error(e.stack),process.exit(1)}}))},e.prototype.testFile=function(e){var t=this;return this.conditions.every((function(r){var n=r.matchedFiles,i=r.checkFn,o=r.expression;try{var a=i([e],t.precedingGroups);return a&&n.add(e),a}catch(e){if(e instanceof PullApproveGroupStateDependencyError)return r.unverifiable=!0,!0;error("Condition could not be evaluated: \n\nFrom the ["+t.groupName+"] group:\n - "+o+"\n\n"+e.message+" "+e.stack+"\n\n"),process.exit(1)}}))},e.prototype.getResults=function(){var e=this.conditions.filter((function(e){return e.matchedFiles.size>0})),t=this.conditions.filter((function(e){return 0===e.matchedFiles.size&&!e.unverifiable})),r=this.conditions.filter((function(e){return e.unverifiable}));return{matchedConditions:e,matchedCount:e.length,unmatchedConditions:t,unmatchedCount:t.length,unverifiableConditions:r,groupName:this.groupName}},e}();function parsePullApproveYaml(e){return yaml.parse(e,{merge:!0})}function getGroupsFromYaml(e){var t=parsePullApproveYaml(e);return Object.entries(t.groups).reduce((function(e,t){var r=tslib.__read(t,2);return e.concat(new PullApproveGroup(r[0],r[1],e))}),[])}function verify(){var e=path.resolve(getRepoBaseDir(),".pullapprove.yml"),t=allFiles(),r=getGroupsFromYaml(fs.readFileSync(e,"utf8")),n=r.filter((function(e){return!e.conditions.length})),i=r.filter((function(e){return!!e.conditions.length})),o=[],a=[];t.forEach((function(e){i.filter((function(t){return t.testFile(e)})).length?o.push(e):a.push(e)}));var s=i.map((function(e){return e.getResults()})),u=s.every((function(e){return!e.unmatchedCount}))&&!a.length;logHeader("Overall Result"),u?info("PullApprove verification succeeded!"):(info("PullApprove verification failed."),info(),info("Please update '.pullapprove.yml' to ensure that all necessary"),info("files/directories have owners and all patterns that appear in"),info("the file correspond to actual files/directories in the repo.")),logHeader("PullApprove results by file"),info.group("Matched Files ("+o.length+" files)"),o.forEach((function(e){return debug(e)})),info.groupEnd(),info.group("Unmatched Files ("+a.length+" files)"),a.forEach((function(e){return info(e)})),info.groupEnd(),logHeader("PullApprove results by group"),info.group("Groups skipped ("+n.length+" groups)"),n.forEach((function(e){return debug(""+e.groupName)})),info.groupEnd();var c=s.filter((function(e){return!e.unmatchedCount}));info.group("Matched conditions by Group ("+c.length+" groups)"),c.forEach((function(e){return logGroup(e,"matchedConditions",debug)})),info.groupEnd();var l=s.filter((function(e){return e.unmatchedCount}));info.group("Unmatched conditions by Group ("+l.length+" groups)"),l.forEach((function(e){return logGroup(e,"unmatchedConditions")})),info.groupEnd();var h=s.filter((function(e){return e.unverifiableConditions.length>0}));info.group("Unverifiable conditions by Group ("+h.length+" groups)"),h.forEach((function(e){return logGroup(e,"unverifiableConditions")})),info.groupEnd(),process.exit(u?0:1)}function buildPullapproveParser(e){return e.help().strict().demandCommand().command("verify","Verify the pullapprove config",{},(function(){return verify()}))}function getReleaseConfig(e=getConfig()){var t,r,n;const i=[];return void 0===e.release&&i.push('No configuration defined for "release"'),void 0===(null===(t=e.release)||void 0===t?void 0:t.npmPackages)&&i.push('No "npmPackages" configured for releasing.'),void 0===(null===(r=e.release)||void 0===r?void 0:r.buildPackages)&&i.push('No "buildPackages" function configured for releasing.'),void 0===(null===(n=e.release)||void 0===n?void 0:n.generateReleaseNotesForHead)&&i.push('No "generateReleaseNotesForHead" function configured for releasing.'),assertNoErrors(i),e.release}function buildReleaseOutput(){return tslib.__awaiter(this,void 0,void 0,(function*(){return new Promise(e=>{const t=child_process.fork(require.resolve("./build-worker"),[],{stdio:["inherit",2,2,"ipc"]});let r=null;t.on("message",e=>r=e),t.on("exit",()=>e(r))})}))}function builder$6(e){return e.option("json",{type:"boolean",description:"Whether the built packages should be printed to stdout as JSON.",default:!1})}function handler$6(e){return tslib.__awaiter(this,void 0,void 0,(function*(){const{npmPackages:t}=getReleaseConfig();let r=yield buildReleaseOutput();null===r&&(error(red("  ✘   Could not build release output. Please check output above.")),process.exit(1)),0===r.length&&(error(red("  ✘   No release packages have been built. Please ensure that the")),error(red('      build script is configured correctly in ".ng-dev".')),process.exit(1));const n=t.filter(e=>!r.find(t=>t.name===e));n.length>0&&(error(red("  ✘   Release output missing for the following packages:")),n.forEach(e=>error(red(`      - ${e}`))),process.exit(1)),e.json?process.stdout.write(JSON.stringify(r,null,2)):(info(green("  ✓   Built release packages.")),r.forEach(({name:e})=>info(green(`      - ${e}`))))}))}const ReleaseBuildCommandModule={builder:builder$6,handler:handler$6,command:"build",describe:"Builds the release output for the current branch."};class ReleaseTrain{constructor(e,t){this.branchName=e,this.version=t,this.isMajor=0===this.version.minor&&0===this.version.patch}}const versionBranchNameRegex=/(\d+)\.(\d+)\.x/;function getVersionOfBranch(e,t){return tslib.__awaiter(this,void 0,void 0,(function*(){const{data:r}=yield e.api.repos.getContents({owner:e.owner,repo:e.name,path:"/package.json",ref:t}),{version:n}=JSON.parse(Buffer.from(r.content,"base64").toString()),i=semver.parse(n);if(null===i)throw Error(`Invalid version detected in following branch: ${t}.`);return i}))}function isVersionBranch(e){return versionBranchNameRegex.test(e)}function getVersionForVersionBranch(e){return semver.parse(e.replace(versionBranchNameRegex,"$1.$2.0"))}function getBranchesForMajorVersions(e,t){return tslib.__awaiter(this,void 0,void 0,(function*(){const{data:r}=yield e.api.repos.listBranches({owner:e.owner,repo:e.name,protected:!0}),n=[];for(const{name:e}of r){if(!isVersionBranch(e))continue;const r=getVersionForVersionBranch(e);null!==r&&t.includes(r.major)&&n.push({name:e,parsed:r})}return n.sort((e,t)=>semver.rcompare(e.parsed,t.parsed))}))}const nextBranchName="master";function fetchActiveReleaseTrains(e){return tslib.__awaiter(this,void 0,void 0,(function*(){const t=yield getVersionOfBranch(e,"master"),r=new ReleaseTrain("master",t),n=[];let i;0===t.minor?(i=t.major-1,n.push(t.major-1)):1===t.minor?(i=t.major,n.push(t.major,t.major-1)):(i=t.major,n.push(t.major));const o=yield getBranchesForMajorVersions(e,n),{latest:a,releaseCandidate:s}=yield findActiveReleaseTrainsFromVersionBranches(e,t,o,i);if(null===a)throw Error("Unable to determine the latest release-train. The following branches "+`have been considered: [${o.map(e=>e.name).join(", ")}]`);return{releaseCandidate:s,latest:a,next:r}}))}function findActiveReleaseTrainsFromVersionBranches(e,t,r,n){return tslib.__awaiter(this,void 0,void 0,(function*(){const i=semver.parse(`${t.major}.${t.minor}.0`);let o=null,a=null;for(const{name:t,parsed:s}of r){if(semver.gt(s,i))throw Error(`Discovered unexpected version-branch "${t}" for a release-train that is `+'more recent than the release-train currently in the "master" branch. Please either delete the branch if created by accident, or update the outdated version in the next branch (master).');if(semver.eq(s,i))throw Error(`Discovered unexpected version-branch "${t}" for a release-train that is already `+'active in the "master" branch. Please either delete the branch if created by accident, or update the version in the next branch (master).');const r=yield getVersionOfBranch(e,t),u=new ReleaseTrain(t,r);if("rc"!==r.prerelease[0]&&"next"!==r.prerelease[0]){o=u;break}if(null!==a)throw Error("Unable to determine latest release-train. Found two consecutive "+`branches in feature-freeze/release-candidate phase. Did not expect both "${t}" `+`and "${a.branchName}" to be in feature-freeze/release-candidate mode.`);if(r.major!==n)throw Error("Discovered unexpected old feature-freeze/release-candidate branch. Expected no "+`version-branch in feature-freeze/release-candidate mode for v${r.major}.`);a=u}return{releaseCandidate:a,latest:o}}))}const _npmPackageInfoCache={};function fetchProjectNpmPackageInfo(e){return tslib.__awaiter(this,void 0,void 0,(function*(){const t=getRepresentativeNpmPackage(e);return yield fetchPackageInfoFromNpmRegistry(t)}))}function isVersionPublishedToNpm(e,t){return tslib.__awaiter(this,void 0,void 0,(function*(){const{versions:r}=yield fetchProjectNpmPackageInfo(t);return void 0!==r[e.format()]}))}function getRepresentativeNpmPackage(e){return e.npmPackages[0]}function fetchPackageInfoFromNpmRegistry(e){return tslib.__awaiter(this,void 0,void 0,(function*(){if(void 0!==_npmPackageInfoCache[e])return yield _npmPackageInfoCache[e];const t=_npmPackageInfoCache[e]=fetch(`https://registry.npmjs.org/${e}`).then(e=>e.json());return yield t}))}const majorActiveSupportDuration=6,majorActiveTermSupportDuration=12,ltsNpmDistTagRegex=/^v(\d+)-lts$/;function fetchLongTermSupportBranchesFromNpm(e){return tslib.__awaiter(this,void 0,void 0,(function*(){const{"dist-tags":t,time:r}=yield fetchProjectNpmPackageInfo(e),n=new Date,i=[],o=[];for(const e in t)if(ltsNpmDistTagRegex.test(e)){const a=semver.parse(t[e]),s={name:`${a.major}.${a.minor}.x`,version:a,npmDistTag:e};n<=computeLtsEndDateOfMajor(new Date(r[`${a.major}.0.0`]))?i.push(s):o.push(s)}return i.sort((e,t)=>semver.rcompare(e.version,t.version)),o.sort((e,t)=>semver.rcompare(e.version,t.version)),{active:i,inactive:o}}))}function computeLtsEndDateOfMajor(e){return new Date(e.getFullYear(),e.getMonth()+6+12,e.getDate(),e.getHours(),e.getMinutes(),e.getSeconds(),e.getMilliseconds())}function getLtsNpmDistTagOfMajor(e){return`v${e}-lts`}function printActiveReleaseTrains(e,t){return tslib.__awaiter(this,void 0,void 0,(function*(){const{releaseCandidate:r,next:n,latest:i}=e,o=yield isVersionPublishedToNpm(n.version,t),a=n.isMajor?"major":"minor",s=yield fetchLongTermSupportBranchesFromNpm(t);if(info(),info(blue("Current version branches in the project:")),null!==r){const e=r.version,t=r.isMajor?"major":"minor",n="next"===e.prerelease[0]?"feature-freeze":"release-candidate";info(` • ${bold(r.branchName)} contains changes for an upcoming `+`${t} that is currently in ${bold(n)} phase.`),info(`   Most recent pre-release for this branch is "${bold(`v${e}`)}".`)}if(info(` • ${bold(i.branchName)} contains changes for the most recent patch.`),info(`   Most recent patch version for this branch is "${bold(`v${i.version}`)}".`),info(` • ${bold(n.branchName)} contains changes for a ${a} `+"currently in active development."),info(o?`   Most recent pre-release version for this branch is "${bold(`v${n.version}`)}".`:`   Version is currently set to "${bold(`v${n.version}`)}", but has not been `+"published yet."),null===r&&info(" • No release-candidate or feature-freeze branch currently active."),info(),info(blue("Current active LTS version branches:")),0!==s.active.length)for(const e of s.active)info(` • ${bold(e.name)} is currently in active long-term support phase.`),info(`   Most recent patch version for this branch is "${bold(`v${e.version}`)}".`);info()}))}class UserAbortedReleaseActionError extends Error{constructor(){super(),Object.setPrototypeOf(this,UserAbortedReleaseActionError.prototype)}}class FatalReleaseActionError extends Error{constructor(){super(),Object.setPrototypeOf(this,FatalReleaseActionError.prototype)}}function semverInc(e,t,r){return new semver.SemVer(e.version).inc(t,r)}function spawnWithDebugOutput(e,t,r){return void 0===r&&(r={}),new Promise((function(n,i){var o=e+" "+t.join(" "),a=r.mode;debug("Executing command: "+o);var s=child_process.spawn(e,t,tslib.__assign(tslib.__assign({},r),{shell:!0,stdio:["inherit","pipe","pipe"]})),u="",c="";s.stderr.on("data",(function(e){u+=e,void 0!==a&&"enabled"!==a||process.stderr.write(e)})),s.stdout.on("data",(function(e){c+=e,u+=e,void 0!==a&&"enabled"!==a||process.stderr.write(e)})),s.on("exit",(function(e,t){var r="on-error"===a?error:debug;r("Command "+o+" completed with "+(null!==e?'exit code "'+e+'"':'signal "'+t+'"')+"."),r("Process output: \n"+u),0===e?n({stdout:c}):i("silent"===a?u:void 0)}))}))}function runNpmPublish(e,t,r){return tslib.__awaiter(this,void 0,void 0,(function*(){const n=["publish","--access","public","--tag",t];void 0!==r&&n.push("--registry",r),yield spawnWithDebugOutput("npm",n,{cwd:e,mode:"silent"})}))}function setNpmTagForPackage(e,t,r,n){return tslib.__awaiter(this,void 0,void 0,(function*(){const i=["dist-tag","add",`${e}@${r}`,t];void 0!==n&&i.push("--registry",n),yield spawnWithDebugOutput("npm",i,{mode:"silent"})}))}function getCommitMessageForRelease(e){return`release: cut the v${e} release`}function getCommitMessageForExceptionalNextVersionBump(e){return`release: bump the next branch to v${e}`}function getReleaseNoteCherryPickCommitMessage(e){return`docs: release notes for the v${e} release`}const changelogPath="CHANGELOG.md",packageJsonPath="package.json",waitForPullRequestInterval=1e4;function invokeSetNpmDistCommand(e,t){return tslib.__awaiter(this,void 0,void 0,(function*(){try{yield spawnWithDebugOutput("yarn",["--silent","ng-dev","release","set-dist-tag",e,t.format()]),info(green(`  ✓   Set "${e}" NPM dist tag for all packages to v${t}.`))}catch(t){throw error(t),error(red(`  ✘   An error occurred while setting the NPM dist tag for ${e}.`)),new FatalReleaseActionError}}))}function invokeReleaseBuildCommand(){return tslib.__awaiter(this,void 0,void 0,(function*(){const e=Ora.call(void 0).start("Building release output.");try{const{stdout:t}=yield spawnWithDebugOutput("yarn",["--silent","ng-dev","release","build","--json"],{mode:"silent"});return e.stop(),info(green("  ✓   Built release output for all packages.")),JSON.parse(t.trim())}catch(t){throw e.stop(),error(t),error(red("  ✘   An error occurred while building the release packages.")),new FatalReleaseActionError}}))}function invokeYarnInstallCommand(e){return tslib.__awaiter(this,void 0,void 0,(function*(){try{yield spawnWithDebugOutput("yarn",["install","--frozen-lockfile","--non-interactive"],{cwd:e}),info(green("  ✓   Installed project dependencies."))}catch(e){throw error(e),error(red("  ✘   An error occurred while installing dependencies.")),new FatalReleaseActionError}}))}const findOwnedForksOfRepoQuery=typedGraphqlify.params({$owner:"String!",$name:"String!"},{repository:typedGraphqlify.params({owner:"$owner",name:"$name"},{forks:typedGraphqlify.params({affiliations:"OWNER",first:1},{nodes:[{owner:{login:typedGraphqlify.types.string},name:typedGraphqlify.types.string}]})})});function getPullRequestState(e,t){return tslib.__awaiter(this,void 0,void 0,(function*(){const{data:r}=yield e.github.pulls.get(Object.assign(Object.assign({},e.remoteParams),{pull_number:t}));return r.merged?"merged":null!==r.closed_at?(yield isPullRequestClosedWithAssociatedCommit(e,t))?"merged":"closed":"open"}))}function isPullRequestClosedWithAssociatedCommit(e,t){return tslib.__awaiter(this,void 0,void 0,(function*(){const r=e.github.issues.listEvents.endpoint.merge(Object.assign(Object.assign({},e.remoteParams),{issue_number:t})),n=yield e.github.paginate(r);for(let r=n.length-1;r>=0;r--){const{event:i,commit_id:o}=n[r];if("reopened"===i)return!1;if("closed"===i&&o)return!0;if("referenced"===i&&o&&(yield isCommitClosingPullRequest(e,o,t)))return!0}return!1}))}function isCommitClosingPullRequest(e,t,r){return tslib.__awaiter(this,void 0,void 0,(function*(){const{data:n}=yield e.github.repos.getCommit(Object.assign(Object.assign({},e.remoteParams),{ref:t}));return n.commit.message.match(new RegExp(`close[sd]? #${r}[^0-9]?`,"i"))}))}function getDefaultExtractReleaseNotesPattern(e){const t=e.format().replace(".","\\.");return new RegExp(`(<a name="${t}"></a>.*?)(?:<a name="|$)`,"s")}function getLocalChangelogFilePath(e){return path.join(e,changelogPath)}class ReleaseAction{constructor(e,t,r,n){this.active=e,this.git=t,this.config=r,this.projectDir=n,this._cachedForkRepo=null}static isActive(e){throw Error("Not implemented.")}updateProjectVersion(e){return tslib.__awaiter(this,void 0,void 0,(function*(){const t=path.join(this.projectDir,"package.json"),r=JSON.parse(yield fs.promises.readFile(t,"utf8"));r.version=e.format(),yield fs.promises.writeFile(t,`${JSON.stringify(r,null,2)}\n`),info(green(`  ✓   Updated project version to ${r.version}`))}))}_getCommitOfBranch(e){return tslib.__awaiter(this,void 0,void 0,(function*(){const{data:{commit:t}}=yield this.git.github.repos.getBranch(Object.assign(Object.assign({},this.git.remoteParams),{branch:e}));return t.sha}))}verifyPassingGithubStatus(e){return tslib.__awaiter(this,void 0,void 0,(function*(){const t=yield this._getCommitOfBranch(e),{data:{state:r}}=yield this.git.github.repos.getCombinedStatusForRef(Object.assign(Object.assign({},this.git.remoteParams),{ref:t})),n=getListCommitsInBranchUrl(this.git,e);if("failure"===r){if(error(red(`  ✘   Cannot stage release. Commit "${t}" does not pass all github `+"status checks. Please make sure this commit passes all checks before re-running.")),error(`      Please have a look at: ${n}`),yield promptConfirm("Do you want to ignore the Github status and proceed?"))return void info(yellow("  ⚠   Upstream commit is failing CI checks, but status has been forcibly ignored."));throw new UserAbortedReleaseActionError}if("pending"===r){if(error(red(`  ✘   Commit "${t}" still has pending github statuses that `+"need to succeed before staging a release.")),error(red(`      Please have a look at: ${n}`)),yield promptConfirm("Do you want to ignore the Github status and proceed?"))return void info(yellow("  ⚠   Upstream commit is pending CI, but status has been forcibly ignored."));throw new UserAbortedReleaseActionError}info(green("  ✓   Upstream commit is passing all github status checks."))}))}_generateReleaseNotesForHead(e){return tslib.__awaiter(this,void 0,void 0,(function*(){const t=getLocalChangelogFilePath(this.projectDir);yield this.config.generateReleaseNotesForHead(t),info(green(`  ✓   Updated the changelog to capture changes for "${e}".`))}))}_extractReleaseNotesForVersion(e,t){const r=(void 0!==this.config.extractReleaseNotesPattern?this.config.extractReleaseNotesPattern(t):getDefaultExtractReleaseNotesPattern(t)).exec(e);return null===r?null:r[1]}waitForEditsAndCreateReleaseCommit(e){return tslib.__awaiter(this,void 0,void 0,(function*(){if(info(yellow("  ⚠   Please review the changelog and ensure that the log contains only changes that apply to the public API surface. Manual changes can be made. When done, please proceed with the prompt below.")),!(yield promptConfirm("Do you want to proceed and commit the changes?")))throw new UserAbortedReleaseActionError;const t=getCommitMessageForRelease(e);yield this.createCommit(t,["package.json",changelogPath]),info(green(`  ✓   Created release commit for: "${e}".`))}))}_getForkOfAuthenticatedUser(){return tslib.__awaiter(this,void 0,void 0,(function*(){if(null!==this._cachedForkRepo)return this._cachedForkRepo;const{owner:e,name:t}=this.git.remoteConfig,r=(yield this.git.github.graphql.query(findOwnedForksOfRepoQuery,{owner:e,name:t})).repository.forks.nodes;if(0===r.length)throw error(red("  ✘   Unable to find fork for currently authenticated user.")),error(red(`      Please ensure you created a fork of: ${e}/${t}.`)),new FatalReleaseActionError;const n=r[0];return this._cachedForkRepo={owner:n.owner.login,name:n.name}}))}_isBranchNameReservedInRepo(e,t){return tslib.__awaiter(this,void 0,void 0,(function*(){try{return yield this.git.github.repos.getBranch({owner:e.owner,repo:e.name,branch:t}),!0}catch(e){if(404===e.status)return!1;throw e}}))}_findAvailableBranchName(e,t){return tslib.__awaiter(this,void 0,void 0,(function*(){let r=t,n=0;for(;yield this._isBranchNameReservedInRepo(e,r);)n++,r=`${t}_${n}`;return r}))}createLocalBranchFromHead(e){return tslib.__awaiter(this,void 0,void 0,(function*(){this.git.run(["checkout","-B",e])}))}pushHeadToRemoteBranch(e){return tslib.__awaiter(this,void 0,void 0,(function*(){this.git.run(["push",this.git.repoGitUrl,`HEAD:refs/heads/${e}`])}))}_pushHeadToFork(e,t){return tslib.__awaiter(this,void 0,void 0,(function*(){const r=yield this._getForkOfAuthenticatedUser(),n=getRepositoryGitUrl(Object.assign(Object.assign({},r),{useSsh:this.git.remoteConfig.useSsh}),this.git.githubToken),i=yield this._findAvailableBranchName(r,e),o=[];return t&&(yield this.createLocalBranchFromHead(i),o.push("--set-upstream")),this.git.run(["push",n,`HEAD:refs/heads/${i}`,...o]),{fork:r,branchName:i}}))}pushChangesToForkAndCreatePullRequest(e,t,r,n){return tslib.__awaiter(this,void 0,void 0,(function*(){const i=`${this.git.remoteParams.owner}/${this.git.remoteParams.repo}`,{fork:o,branchName:a}=yield this._pushHeadToFork(t,!0),{data:s}=yield this.git.github.pulls.create(Object.assign(Object.assign({},this.git.remoteParams),{head:`${o.owner}:${a}`,base:e,body:n,title:r}));return info(green(`  ✓   Created pull request #${s.number} in ${i}.`)),{id:s.number,url:s.html_url,fork:o,forkBranch:a}}))}waitForPullRequestToBeMerged(e,t=1e4){return tslib.__awaiter(this,void 0,void 0,(function*(){return new Promise((r,n)=>{debug(`Waiting for pull request #${e} to be merged.`);const i=Ora.call(void 0).start(`Waiting for pull request #${e} to be merged.`),o=setInterval(()=>tslib.__awaiter(this,void 0,void 0,(function*(){const t=yield getPullRequestState(this.git,e);"merged"===t?(i.stop(),info(green(`  ✓   Pull request #${e} has been merged.`)),clearInterval(o),r()):"closed"===t&&(i.stop(),warn(yellow(`  ✘   Pull request #${e} has been closed.`)),clearInterval(o),n(new UserAbortedReleaseActionError))})),t)})}))}prependReleaseNotesFromVersionBranch(e,t){return tslib.__awaiter(this,void 0,void 0,(function*(){const{data:r}=yield this.git.github.repos.getContents(Object.assign(Object.assign({},this.git.remoteParams),{path:"/CHANGELOG.md",ref:t})),n=Buffer.from(r.content,"base64").toString();let i=this._extractReleaseNotesForVersion(n,e);if(null===i)return!1;const o=getLocalChangelogFilePath(this.projectDir),a=yield fs.promises.readFile(o,"utf8");return/[\r\n]+$/.test(i)||""===a||(i=`${i}\n\n`),yield fs.promises.writeFile(o,i+a),!0}))}checkoutUpstreamBranch(e){return tslib.__awaiter(this,void 0,void 0,(function*(){this.git.run(["fetch",this.git.repoGitUrl,e]),this.git.run(["checkout","FETCH_HEAD","--detach"])}))}createCommit(e,t){return tslib.__awaiter(this,void 0,void 0,(function*(){this.git.run(["commit","--no-verify","-m",e,...t])}))}createCherryPickReleaseNotesCommitFrom(e,t){return tslib.__awaiter(this,void 0,void 0,(function*(){const r=getReleaseNoteCherryPickCommitMessage(e);return!!(yield this.prependReleaseNotesFromVersionBranch(e,t))&&(yield this.createCommit(r,[changelogPath]),info(green(`  ✓   Created changelog cherry-pick commit for: "${e}".`)),!0)}))}stageVersionForBranchAndCreatePullRequest(e,t){return tslib.__awaiter(this,void 0,void 0,(function*(){yield this.updateProjectVersion(e),yield this._generateReleaseNotesForHead(e),yield this.waitForEditsAndCreateReleaseCommit(e);const r=yield this.pushChangesToForkAndCreatePullRequest(t,`release-stage-${e}`,`Bump version to "v${e}" with changelog.`);return info(green("  ✓   Release staging pull request has been created.")),info(yellow(`      Please ask team members to review: ${r.url}.`)),r}))}checkoutBranchAndStageVersion(e,t){return tslib.__awaiter(this,void 0,void 0,(function*(){return yield this.verifyPassingGithubStatus(t),yield this.checkoutUpstreamBranch(t),yield this.stageVersionForBranchAndCreatePullRequest(e,t)}))}cherryPickChangelogIntoNextBranch(e,t){return tslib.__awaiter(this,void 0,void 0,(function*(){const r=this.active.next.branchName,n=getReleaseNoteCherryPickCommitMessage(e);if(yield this.checkoutUpstreamBranch(r),!(yield this.createCherryPickReleaseNotesCommitFrom(e,t)))return error(yellow(`  ✘   Could not cherry-pick release notes for v${e}.`)),error(yellow(`      Please copy the release notes manually into the "${r}" branch.`)),!1;const{url:i}=yield this.pushChangesToForkAndCreatePullRequest(r,`changelog-cherry-pick-${e}`,n,`Cherry-picks the changelog from the "${t}" branch to the next `+`branch (${r}).`);return info(green(`  ✓   Pull request for cherry-picking the changelog into "${r}" `+"has been created.")),info(yellow(`      Please ask team members to review: ${i}.`)),!0}))}_createGithubReleaseForVersion(e,t){return tslib.__awaiter(this,void 0,void 0,(function*(){const r=e.format();yield this.git.github.git.createRef(Object.assign(Object.assign({},this.git.remoteParams),{ref:`refs/tags/${r}`,sha:t})),info(green(`  ✓   Tagged v${e} release upstream.`)),yield this.git.github.repos.createRelease(Object.assign(Object.assign({},this.git.remoteParams),{name:`v${e}`,tag_name:r})),info(green(`  ✓   Created v${e} release in Github.`))}))}buildAndPublish(e,t,r){return tslib.__awaiter(this,void 0,void 0,(function*(){const n=yield this._getCommitOfBranch(t);if(!(yield this._isCommitForVersionStaging(e,n)))throw error(red(`  ✘   Latest commit in "${t}" branch is not a staging commit.`)),error(red("      Please make sure the staging pull request has been merged.")),new FatalReleaseActionError;yield this.checkoutUpstreamBranch(t),yield invokeYarnInstallCommand(this.projectDir);const i=yield invokeReleaseBuildCommand();yield this._createGithubReleaseForVersion(e,n);for(const e of i)yield this._publishBuiltPackageToNpm(e,r);info(green("  ✓   Published all packages successfully"))}))}_publishBuiltPackageToNpm(e,t){return tslib.__awaiter(this,void 0,void 0,(function*(){debug(`Starting publish of "${e.name}".`);const r=Ora.call(void 0).start(`Publishing "${e.name}"`);try{yield runNpmPublish(e.outputPath,t,this.config.publishRegistry),r.stop(),info(green(`  ✓   Successfully published "${e.name}.`))}catch(t){throw r.stop(),error(t),error(red(`  ✘   An error occurred while publishing "${e.name}".`)),new FatalReleaseActionError}}))}_isCommitForVersionStaging(e,t){return tslib.__awaiter(this,void 0,void 0,(function*(){const{data:r}=yield this.git.github.repos.getCommit(Object.assign(Object.assign({},this.git.remoteParams),{ref:t}));return r.commit.message.startsWith(getCommitMessageForRelease(e))}))}}class CutLongTermSupportPatchAction extends ReleaseAction{constructor(){super(...arguments),this.ltsBranches=fetchLongTermSupportBranchesFromNpm(this.config)}getDescription(){return tslib.__awaiter(this,void 0,void 0,(function*(){const{active:e}=yield this.ltsBranches;return`Cut a new release for an active LTS branch (${e.length} active).`}))}perform(){return tslib.__awaiter(this,void 0,void 0,(function*(){const e=yield this._promptForTargetLtsBranch(),t=semverInc(e.version,"patch"),{id:r}=yield this.checkoutBranchAndStageVersion(t,e.name);yield this.waitForPullRequestToBeMerged(r),yield this.buildAndPublish(t,e.name,e.npmDistTag),yield this.cherryPickChangelogIntoNextBranch(t,e.name)}))}_promptForTargetLtsBranch(){return tslib.__awaiter(this,void 0,void 0,(function*(){const{active:e,inactive:t}=yield this.ltsBranches,r=e.map(e=>this._getChoiceForLtsBranch(e));0!==t.length&&r.push({name:"Inactive LTS versions (not recommended)",value:null});const{activeLtsBranch:n,inactiveLtsBranch:i}=yield inquirer.prompt([{name:"activeLtsBranch",type:"list",message:"Please select a version for which you want to cut a LTS patch",choices:r},{name:"inactiveLtsBranch",type:"list",when:e=>null===e.activeLtsBranch,message:"Please select an inactive LTS version for which you want to cut a LTS patch",choices:t.map(e=>this._getChoiceForLtsBranch(e))}]);return null!=n?n:i}))}_getChoiceForLtsBranch(e){return{name:`v${e.version.major} (from ${e.name})`,value:e}}static isActive(e){return tslib.__awaiter(this,void 0,void 0,(function*(){return!0}))}}class CutNewPatchAction extends ReleaseAction{constructor(){super(...arguments),this._newVersion=semverInc(this.active.latest.version,"patch")}getDescription(){return tslib.__awaiter(this,void 0,void 0,(function*(){const{branchName:e}=this.active.latest;return`Cut a new patch release for the "${e}" branch (v${this._newVersion}).`}))}perform(){return tslib.__awaiter(this,void 0,void 0,(function*(){const{branchName:e}=this.active.latest,t=this._newVersion,{id:r}=yield this.checkoutBranchAndStageVersion(t,e);yield this.waitForPullRequestToBeMerged(r),yield this.buildAndPublish(t,e,"latest"),yield this.cherryPickChangelogIntoNextBranch(t,e)}))}static isActive(e){return tslib.__awaiter(this,void 0,void 0,(function*(){return!0}))}}function computeNewPrereleaseVersionForNext(e,t){return tslib.__awaiter(this,void 0,void 0,(function*(){const{version:r}=e.next;return(yield isVersionPublishedToNpm(r,t))?semverInc(r,"prerelease"):r}))}class CutNextPrereleaseAction extends ReleaseAction{constructor(){super(...arguments),this._newVersion=this._computeNewVersion()}getDescription(){return tslib.__awaiter(this,void 0,void 0,(function*(){const{branchName:e}=this._getActivePrereleaseTrain();return`Cut a new next pre-release for the "${e}" branch (v${yield this._newVersion}).`}))}perform(){return tslib.__awaiter(this,void 0,void 0,(function*(){const e=this._getActivePrereleaseTrain(),{branchName:t}=e,r=yield this._newVersion,{id:n}=yield this.checkoutBranchAndStageVersion(r,t);yield this.waitForPullRequestToBeMerged(n),yield this.buildAndPublish(r,t,"next"),e!==this.active.next&&(yield this.cherryPickChangelogIntoNextBranch(r,t))}))}_getActivePrereleaseTrain(){var e;return null!==(e=this.active.releaseCandidate)&&void 0!==e?e:this.active.next}_computeNewVersion(){return tslib.__awaiter(this,void 0,void 0,(function*(){const e=this._getActivePrereleaseTrain();return e===this.active.next?yield computeNewPrereleaseVersionForNext(this.active,this.config):semverInc(e.version,"prerelease")}))}static isActive(){return tslib.__awaiter(this,void 0,void 0,(function*(){return!0}))}}class CutReleaseCandidateAction extends ReleaseAction{constructor(){super(...arguments),this._newVersion=semverInc(this.active.releaseCandidate.version,"prerelease","rc")}getDescription(){return tslib.__awaiter(this,void 0,void 0,(function*(){return`Cut a first release-candidate for the feature-freeze branch (v${this._newVersion}).`}))}perform(){return tslib.__awaiter(this,void 0,void 0,(function*(){const{branchName:e}=this.active.releaseCandidate,t=this._newVersion,{id:r}=yield this.checkoutBranchAndStageVersion(t,e);yield this.waitForPullRequestToBeMerged(r),yield this.buildAndPublish(t,e,"next"),yield this.cherryPickChangelogIntoNextBranch(t,e)}))}static isActive(e){return tslib.__awaiter(this,void 0,void 0,(function*(){return null!==e.releaseCandidate&&"next"===e.releaseCandidate.version.prerelease[0]}))}}class CutStableAction extends ReleaseAction{constructor(){super(...arguments),this._newVersion=this._computeNewVersion()}getDescription(){return tslib.__awaiter(this,void 0,void 0,(function*(){return`Cut a stable release for the release-candidate branch (v${this._newVersion}).`}))}perform(){var e;return tslib.__awaiter(this,void 0,void 0,(function*(){const{branchName:t}=this.active.releaseCandidate,r=this._newVersion,n=null===(e=this.active.releaseCandidate)||void 0===e?void 0:e.isMajor,{id:i}=yield this.checkoutBranchAndStageVersion(r,t);if(yield this.waitForPullRequestToBeMerged(i),yield this.buildAndPublish(r,t,"latest"),n){const e=this.active.latest.version,t=getLtsNpmDistTagOfMajor(e.major);yield invokeYarnInstallCommand(this.projectDir),yield invokeSetNpmDistCommand(t,e)}yield this.cherryPickChangelogIntoNextBranch(r,t)}))}_computeNewVersion(){const{version:e}=this.active.releaseCandidate;return semver.parse(`${e.major}.${e.minor}.${e.patch}`)}static isActive(e){return tslib.__awaiter(this,void 0,void 0,(function*(){return null!==e.releaseCandidate&&"rc"===e.releaseCandidate.version.prerelease[0]}))}}class MoveNextIntoFeatureFreezeAction extends ReleaseAction{constructor(){super(...arguments),this._newVersion=computeNewPrereleaseVersionForNext(this.active,this.config)}getDescription(){return tslib.__awaiter(this,void 0,void 0,(function*(){const{branchName:e}=this.active.next;return`Move the "${e}" branch into feature-freeze phase (v${yield this._newVersion}).`}))}perform(){return tslib.__awaiter(this,void 0,void 0,(function*(){const e=yield this._newVersion,t=`${e.major}.${e.minor}.x`;yield this._createNewVersionBranchFromNext(t);const r=yield this.stageVersionForBranchAndCreatePullRequest(e,t);yield this.waitForPullRequestToBeMerged(r.id),yield this.buildAndPublish(e,t,"next"),yield this._createNextBranchUpdatePullRequest(e,t)}))}_createNewVersionBranchFromNext(e){return tslib.__awaiter(this,void 0,void 0,(function*(){const{branchName:t}=this.active.next;yield this.verifyPassingGithubStatus(t),yield this.checkoutUpstreamBranch(t),yield this.createLocalBranchFromHead(e),yield this.pushHeadToRemoteBranch(e),info(green(`  ✓   Version branch "${e}" created.`))}))}_createNextBranchUpdatePullRequest(e,t){return tslib.__awaiter(this,void 0,void 0,(function*(){const{branchName:r,version:n}=this.active.next,i=semver.parse(`${n.major}.${n.minor+1}.0-next.0`),o=getCommitMessageForExceptionalNextVersionBump(i);yield this.checkoutUpstreamBranch(r),yield this.updateProjectVersion(i),yield this.createCommit(o,["package.json"]);let a='The previous "next" release-train has moved into the release-candidate phase. This PR updates the next branch to the subsequent release-train.';(yield this.createCherryPickReleaseNotesCommitFrom(e,t))?a+="\n\nAlso this PR cherry-picks the changelog for "+`v${e} into the ${r} branch so that the changelog is up to date.`:(error(yellow(`  ✘   Could not cherry-pick release notes for v${e}.`)),error(yellow(`      Please copy the release note manually into "${r}".`)));const s=yield this.pushChangesToForkAndCreatePullRequest(r,`next-release-train-${i}`,`Update next branch to reflect new release-train "v${i}".`,a);info(green(`  ✓   Pull request for updating the "${r}" branch has been created.`)),info(yellow(`      Please ask team members to review: ${s.url}.`))}))}static isActive(e){return tslib.__awaiter(this,void 0,void 0,(function*(){return null===e.releaseCandidate}))}}const actions=[CutStableAction,CutReleaseCandidateAction,CutNewPatchAction,CutNextPrereleaseAction,MoveNextIntoFeatureFreezeAction,CutLongTermSupportPatchAction];var CompletionState;!function(e){e[e.SUCCESS=0]="SUCCESS",e[e.FATAL_ERROR=1]="FATAL_ERROR",e[e.MANUALLY_ABORTED=2]="MANUALLY_ABORTED"}(CompletionState||(CompletionState={}));class ReleaseTool{constructor(e,t,r,n){this._config=e,this._github=t,this._githubToken=r,this._projectRoot=n,this._git=new GitClient(this._githubToken,{github:this._github},this._projectRoot)}run(){return tslib.__awaiter(this,void 0,void 0,(function*(){if(log(),log(yellow("--------------------------------------------")),log(yellow("  Angular Dev-Infra release staging script")),log(yellow("--------------------------------------------")),log(),!(yield this._verifyNoUncommittedChanges())||!(yield this._verifyRunningFromNextBranch()))return CompletionState.FATAL_ERROR;const{owner:e,name:t}=this._github,r={owner:e,name:t,api:this._git.github},n=yield fetchActiveReleaseTrains(r);yield printActiveReleaseTrains(n,this._config);const i=yield this._promptForReleaseAction(n),o=this._git.getCurrentBranchOrRevision();try{yield i.perform()}catch(e){return e instanceof UserAbortedReleaseActionError?CompletionState.MANUALLY_ABORTED:(!(e instanceof FatalReleaseActionError)&&e instanceof Error&&(console.error(e.message),console.error(e.stack)),CompletionState.FATAL_ERROR)}finally{this._git.checkout(o,!0)}return CompletionState.SUCCESS}))}_promptForReleaseAction(e){return tslib.__awaiter(this,void 0,void 0,(function*(){const t=[];for(let r of actions)if(yield r.isActive(e)){const n=new r(e,this._git,this._config,this._projectRoot);t.push({name:yield n.getDescription(),value:n})}info("Please select the type of release you want to perform.");const{releaseAction:r}=yield inquirer.prompt({name:"releaseAction",message:"Please select an action:",type:"list",choices:t});return r}))}_verifyNoUncommittedChanges(){return tslib.__awaiter(this,void 0,void 0,(function*(){return!this._git.hasUncommittedChanges()||(error(red("  ✘   There are changes which are not committed and should be discarded.")),!1)}))}_verifyRunningFromNextBranch(){return tslib.__awaiter(this,void 0,void 0,(function*(){const e=this._git.run(["rev-parse","HEAD"]).stdout.trim(),{data:t}=yield this._git.github.repos.getBranch(Object.assign(Object.assign({},this._git.remoteParams),{branch:"master"}));return e===t.commit.sha||(error(red("  ✘   Running release tool from an outdated local branch.")),error(red('      Please make sure you are running from the "master" branch.')),!1)}))}}function builder$7(e){return addGithubTokenOption(e)}function handler$7(e){return tslib.__awaiter(this,void 0,void 0,(function*(){const t=getConfig(),r=getReleaseConfig(t),n=getRepoBaseDir(),i=new ReleaseTool(r,t.github,e.githubToken,n);switch(yield i.run()){case CompletionState.FATAL_ERROR:error(red("Release action has been aborted due to fatal errors. See above.")),process.exitCode=1;break;case CompletionState.MANUALLY_ABORTED:info(yellow("Release action has been manually aborted."));break;case CompletionState.SUCCESS:info(green("Release action has completed successfully."))}}))}const ReleasePublishCommandModule={builder:builder$7,handler:handler$7,command:"publish",describe:"Publish new releases and configure version branches."};function builder$8(e){return e.positional("tagName",{type:"string",demandOption:!0,description:"Name of the NPM dist tag."}).positional("targetVersion",{type:"string",demandOption:!0,description:"Version to which the dist tag should be set."})}function handler$8(e){return tslib.__awaiter(this,void 0,void 0,(function*(){const{targetVersion:t,tagName:r}=e,{npmPackages:n,publishRegistry:i}=getReleaseConfig(),o=semver.parse(t);null===o&&(error(red("Invalid version specified. Unable to set NPM dist tag.")),process.exit(1));const a=Ora.call(void 0).start();debug(`Setting "${r}" NPM dist tag for release packages to v${o}.`);for(const e of n){a.text=`Setting NPM dist tag for "${e}"`,a.render();try{yield setNpmTagForPackage(e,r,o,i),debug(`Successfully set "${r}" NPM dist tag for "${e}".`)}catch(t){a.stop(),error(t),error(red(`  ✘   An error occurred while setting the NPM dist tag for "${e}".`)),process.exit(1)}}a.stop(),info(green("  ✓   Set NPM dist tag for all release packages.")),info(green(`      ${bold(r)} will now point to ${bold(`v${o}`)}.`))}))}const ReleaseSetDistTagCommand={builder:builder$8,handler:handler$8,command:"set-dist-tag <tag-name> <target-version>",describe:"Sets a given NPM dist tag for all release packages."};function buildEnvStamp(){console.info("BUILD_SCM_BRANCH "+getCurrentBranch()),console.info("BUILD_SCM_COMMIT_SHA "+getCurrentSha()),console.info("BUILD_SCM_HASH "+getCurrentSha()),console.info("BUILD_SCM_LOCAL_CHANGES "+hasLocalChanges()),console.info("BUILD_SCM_USER "+getCurrentGitUser()),console.info("BUILD_SCM_VERSION "+getSCMVersion()),process.exit(0)}function exec$1(e){return exec(e).trim()}function hasLocalChanges(){return!!exec$1("git status --untracked-files=no --porcelain")}function getSCMVersion(){return exec$1("git describe --match [0-9]*.[0-9]*.[0-9]* --abbrev=7 --tags HEAD").replace(/-([0-9]+)-g/,"+$1.sha-")+(hasLocalChanges()?".with-local-changes":"")}function getCurrentSha(){return exec$1("git rev-parse HEAD")}function getCurrentBranch(){return exec$1("git symbolic-ref --short HEAD")}function getCurrentGitUser(){return exec$1("git config user.name")+" <"+exec$1("git config user.email")+">"}function buildReleaseParser(e){return e.help().strict().demandCommand().command(ReleasePublishCommandModule).command(ReleaseBuildCommandModule).command(ReleaseSetDistTagCommand).command("build-env-stamp","Build the environment stamping information",{},(function(){return buildEnvStamp()}))}function getFileStatus(e){try{return fs.statSync(e)}catch(e){return null}}function convertPathToForwardSlash(e){return e.replace(/\\/g,"/")}function getModuleReferences(e){var t=[],r=function(e){(ts.isImportDeclaration(e)||ts.isExportDeclaration(e))&&void 0!==e.moduleSpecifier&&ts.isStringLiteral(e.moduleSpecifier)&&t.push(e.moduleSpecifier.text),ts.forEachChild(e,r)};return ts.forEachChild(e,r),t}var DEFAULT_EXTENSIONS=["ts","js","d.ts"],Analyzer=function(){function e(e,t){void 0===t&&(t=DEFAULT_EXTENSIONS),this.resolveModuleFn=e,this.extensions=t,this._sourceFileCache=new Map,this.unresolvedModules=new Set,this.unresolvedFiles=new Map}return e.prototype.findCycles=function(e,t,r){var n,i;void 0===t&&(t=new WeakSet),void 0===r&&(r=[]);var o=r.indexOf(e);if(-1!==o)return[r.slice(o)];if(t.has(e))return[];r.push(e),t.add(e);var a=[];try{for(var s=tslib.__values(getModuleReferences(e)),u=s.next();!u.done;u=s.next()){var c=this._resolveImport(u.value,e.fileName);null!==c&&a.push.apply(a,tslib.__spread(this.findCycles(this.getSourceFile(c),t,r.slice())))}}catch(e){n={error:e}}finally{try{u&&!u.done&&(i=s.return)&&i.call(s)}finally{if(n)throw n.error}}return a},e.prototype.getSourceFile=function(e){var t=path.resolve(e);if(this._sourceFileCache.has(t))return this._sourceFileCache.get(t);var r=fs.readFileSync(t,"utf8"),n=ts.createSourceFile(t,r,ts.ScriptTarget.Latest,!1);return this._sourceFileCache.set(t,n),n},e.prototype._resolveImport=function(e,t){if("."===e.charAt(0))return null===(r=this._resolveFileSpecifier(e,t))&&this._trackUnresolvedFileImport(e,t),r;if(this.resolveModuleFn){var r,n=this.resolveModuleFn(e);if(null!==n&&null!==(r=this._resolveFileSpecifier(n)))return r}return this.unresolvedModules.add(e),null},e.prototype._trackUnresolvedFileImport=function(e,t){this.unresolvedFiles.has(t)||this.unresolvedFiles.set(t,[e]),this.unresolvedFiles.get(t).push(e)},e.prototype._resolveFileSpecifier=function(e,t){var r,n,i=void 0!==t?path.join(path.dirname(t),e):e,o=getFileStatus(i);if(o&&o.isFile())return i;try{for(var a=tslib.__values(this.extensions),s=a.next();!s.done;s=a.next()){var u=i+"."+s.value,c=getFileStatus(u);if(c&&c.isFile())return u}}catch(e){r={error:e}}finally{try{s&&!s.done&&(n=a.return)&&n.call(a)}finally{if(r)throw r.error}}return o&&o.isDirectory()?this._resolveFileSpecifier(path.join(i,"index")):null},e}();function loadTestConfig(e){var t=path.dirname(e),r=function(e){return path.resolve(t,e)};try{var n=require(e);return path.isAbsolute(n.baseDir)||(n.baseDir=r(n.baseDir)),path.isAbsolute(n.goldenFile)||(n.goldenFile=r(n.goldenFile)),path.isAbsolute(n.glob)||(n.glob=r(n.glob)),n}catch(t){error("Could not load test configuration file at: "+e),error("Failed with: "+t.message),process.exit(1)}}function convertReferenceChainToGolden(e,t){return e.map((function(e){return normalizeCircularDependency(e.map((function(e){return convertPathToForwardSlash(path.relative(t,e.fileName))})))})).sort(compareCircularDependency)}function compareGoldens(e,t){var r=[],n=[];return e.forEach((function(e){t.find((function(t){return isSameCircularDependency(e,t)}))||r.push(e)})),t.forEach((function(t){e.find((function(e){return isSameCircularDependency(t,e)}))||n.push(t)})),{newCircularDeps:r,fixedCircularDeps:n}}function normalizeCircularDependency(e){if(e.length<=1)return e;for(var t=0,r=e[0],n=1;n<e.length;n++){var i=e[n];i.localeCompare(r,"en")<0&&(t=n,r=i)}return 0===t?e:tslib.__spread(e.slice(t),e.slice(0,t))}function isSameCircularDependency(e,t){if(e.length!==t.length)return!1;for(var r=0;r<e.length;r++)if(e[r]!==t[r])return!1;return!0}function compareCircularDependency(e,t){for(var r=0;r<Math.min(e.length,t.length);r++){var n=e[r].localeCompare(t[r],"en");if(0!==n)return n}return e.length-t.length}function tsCircularDependenciesBuilder(e){return e.help().strict().demandCommand().option("config",{type:"string",demandOption:!0,description:"Path to the configuration file."}).option("warnings",{type:"boolean",description:"Prints all warnings."}).command("check","Checks if the circular dependencies have changed.",(function(e){return e}),(function(e){var t=e.config,r=e.warnings,n=loadTestConfig(path.isAbsolute(t)?t:path.resolve(t));process.exit(main(!1,n,!!r))})).command("approve","Approves the current circular dependencies.",(function(e){return e}),(function(e){var t=e.config,r=e.warnings,n=loadTestConfig(path.isAbsolute(t)?t:path.resolve(t));process.exit(main(!0,n,!!r))}))}function main(e,t,r){var n=t.baseDir,i=t.goldenFile,o=t.glob,a=t.approveCommand,s=new Analyzer(t.resolveModule),u=[],c=new WeakSet;glob.sync(o,{absolute:!0}).forEach((function(e){var t=s.getSourceFile(e);u.push.apply(u,tslib.__spread(s.findCycles(t,c)))}));var l=convertReferenceChainToGolden(u,n);if(info(green("   Current number of cycles: "+yellow(u.length.toString()))),e)return fs.writeFileSync(i,JSON.stringify(l,null,2)),info(green("✅  Updated golden file.")),0;if(!fs.existsSync(i))return error(red("❌  Could not find golden file: "+i)),1;var h=s.unresolvedFiles.size+s.unresolvedModules.size;r&&0!==h?(info(yellow("⚠  The following imports could not be resolved:")),Array.from(s.unresolvedModules).sort().forEach((function(e){return info("  • "+e)})),s.unresolvedFiles.forEach((function(e,t){info("  • "+getRelativePath(n,t)),e.sort().forEach((function(e){return info("      "+e)}))}))):(info(yellow("⚠  "+h+" imports could not be resolved.")),info(yellow('   Please rerun with "--warnings" to inspect unresolved imports.')));var d=compareGoldens(l,JSON.parse(fs.readFileSync(i,"utf8"))),f=d.fixedCircularDeps,p=d.newCircularDeps;return 0===f.length&&0===p.length?(info(green("✅  Golden matches current circular dependencies.")),0):(error(red("❌  Golden does not match current circular dependencies.")),0!==p.length&&(error(yellow("   New circular dependencies which are not allowed:")),p.forEach((function(e){return error("     • "+convertReferenceChainToString(e))})),error()),0!==f.length&&(error(yellow("   Fixed circular dependencies that need to be removed from the golden:")),f.forEach((function(e){return error("     • "+convertReferenceChainToString(e))})),info(yellow("\n   Total: "+p.length+" new cycle(s), "+f.length+" fixed cycle(s). \n")),info(yellow(a?"   Please approve the new golden with: "+a:"   Please update the golden. The following command can be run: yarn ts-circular-deps approve "+getRelativePath(process.cwd(),i)+"."))),1)}function getRelativePath(e,t){return convertPathToForwardSlash(path.relative(e,t))}function convertReferenceChainToString(e){return e.join(" → ")}function verify$1(){const e=path.resolve(getRepoBaseDir(),".github/angular-robot.yml"),t=fs.readFileSync(e,"utf8");try{yaml.parse(t),info(`${green("√")}  Valid NgBot YAML config`)}catch(e){error(`${red("!")} Invalid NgBot YAML config`),error(e),process.exitCode=1}}function buildNgbotParser(e){return e.help().strict().demandCommand().command("verify","Verify the NgBot config",{},()=>verify$1())}yargs.scriptName("ng-dev").middleware(captureLogOutputForCommand).demandCommand().recommendCommands().command("commit-message <command>","",buildCommitMessageParser).command("format <command>","",buildFormatParser).command("pr <command>","",buildPrParser).command("pullapprove <command>","",buildPullapproveParser).command("release <command>","",buildReleaseParser).command("ts-circular-deps <command>","",tsCircularDependenciesBuilder).command("caretaker <command>","",buildCaretakerParser).command("ngbot <command>",!1,buildNgbotParser).wrap(120).strict().parse();