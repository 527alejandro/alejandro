# Animation basics

Animation provides the illusion of motion: elements change styling over time.

* Without animations, web page transitions can seem abrupt and jarring.

* Adding motion to your web application greatly enhances the user experience, giving users a chance to detect the application’s response to their own actions.

* Well-designed animations can make your application fun and easier to use.

* Good user interfaces transition smoothly between states with engaging animations that intuitively call the user's attention to where it is needed.

Typically, animations involve multiple style _transformations_ over time – an HTML element can move, change color, grow or shrink, fade, or slide off the page. These changes can occur simultaneously or sequentially. You can control the timing of each of these transformations.

## Audience assumptions

Before starting with Angular animations, readers are advised to review the basic [Tutorial](tutorial) and [Architecture Overview](guide/architecture) sections.

## About Angular animations

Angular's animation system is built on CSS functionality, which means you can animate any property that the browser considers animatable. This includes positions, sizes, transforms, colors, borders, and more. The W3C maintains a list of animatable properties on its [CSS Transitions](https://www.w3.org/TR/css-transitions-1/) page.

The main Angular modules for animations are **@angular/animations** and **@angular/platform-browser**.
If you want to create route-based animations that kick off when the user changes a URL, you’ll also need **@angular/router**.

As of Angular 6, If the Web Animations API is not supported natively by the browser, then Angular will use CSS
keyframes as a fallback instead (automatically). This means that the polyfill is no longer required unless any
code uses [AnimationBuilder](/api/animations/AnimationBuilder). If your code does use AnimationBuilder, then
uncomment the `web-animations-js` polyfill from the `polyfills.ts` file generated by Angular CLI.

Also, check out the full-fledged animation [demo](http://animationsftw.in/#/) with the accompanying [presentation](https://www.youtube.com/watch?v=JhNo3Wvj6UQ&feature=youtu.be&t=2h47m53s), shown at the AngularConnect conference in November 2017.

## How this document is organized

This document begins with simple concepts, and then builds on those to create more complex applications.

Each section follows a similar pattern:

* Describes key concepts and activities, using simple illustrated English-language examples.

* Explains how to implement the functionality in Angular.

* Includes code samples and links to complete demo projects on Stackblitz.

* Details of implementation and expanded usage examples are on a separate "[Animation Basics Deep Dive](guide/animation-basics-deep-dive)" page following all the concept sections.


## Getting Started

To make the code samples work, you’ll need to import the animation-specific modules along with standard Angular functionality.

### Step 1: Dependencies

Add **@angular/animations** and **@angular/platform-browser** to `package.json`. Specify "latest" for all modules, not just the animations.

<code-example hideCopy language="json" title="package.json">
{ 
 "dependencies": { 
   "@angular/animations": "latest", 
   "@angular/platform-browser": "latest", 
   … 
 } 
} 
</code-example>

<div class="l-sub-section">
The code sample assumes that you are using the Angular CLI.
</div>

### Step 2: Import browser modules into root

Import `BrowserModule` and `BrowserAnimationsModule` into your Angular root application module.

<code-example path="animations-guide/src/app/app.module.fake.ts" title="src/app/app.module.ts">
</code-example>

<div class="l-sub-section">

The root application module is typically located in `src/app` and is named `app.module.ts`.
</div>

### Step 3: Import animation functions into component files

Perform this step for every component file that uses animations.

<code-example path="animations-guide/src/app/app.component.ts" title="src/app/app.component.ts" region="imports">
</code-example> 

<div class="l-sub-section">

Import the specific functions that you plan to use, from the items listed under the Animation DSL section of this document.
</div>

### Step 4: Define animations inside @Component decorator

In the component file, add a property called `animations:` to the `@Component` decorator. This lets you define the animations you plan to apply to your component.

<code-example path="animations-guide/src/app/app.component.ts" title="src/app/app.component.ts" region="decorator">
</code-example>

{@a simple-transiton}

## Simple transition example

We’ll start with an animation example that changes a single HTML element from one state to another.
For example, a button can show as either `open` or `closed`, depending on the user's last action.

<figure>
 <img src="generated/images/guide/animations/open-closed-500.png" alt="open and closed states">
</figure>

### Animation State and Styles
Angular's `state()` functions allows you to define different states that you can call at the end of each transition. It takes two arguments: the first argument accepts a unique name like `open` or `closed` and the second argument accepts a `style()` function.

The `style()` function allows you to define a set of styles to associate with a given state name.

Let us see how Angular's `state()` function works together with the `style⁣­(⁠)` function to set CSS style attributes.

<code-example path="animations-guide/src/app/open-close.component.ts" title="src/app/open-close.component.ts" region="state1">
</code-example>

<code-example path="animations-guide/src/app/open-close.component.ts" title="src/app/open-close.component.ts" region="state2">
</code-example>

In the above code snippet,  you can see how states can allow multiple style attributes to be set all at the same time. When the button shows as `Open` it has several style attributes: a height of 200 pixels, an opacity of 1, and a color of yellow. The `style()` function describes what the style should be when the right conditions arise.

In the `closed` state, the button has a height of 100 pixels, an opacity of 0.5, and a background color of green. 

### Transitions
In Angular, you can set multiple styles without any animation. However, without further refinement, the HTML element will instantly transform with no fade, no shrinkage, or other visible indicator that a change is occurring. The `transition()` function makes the actual animation to occur.

To make the change less abrupt, we need an animation transition to describe the changes that occur between one state and another over a defined period of time. It accepts two arguments: the first argument accepts an expression that defines how the animation will be executed, and the second argument accepts an `animate()` function.

The `animate()` function allows you to define the length, delay, and easing of a transition. It also allows you to designate the style function for defining styles while the transitions are taking place, or the keyframes function for multi-step animations; both of which are placed in the second argument of the animate function.

For our example, let us provide a transition from `open` to `closed` state with a durations of 1s between transitions.

Note the arrow syntax used in the code snippet below. Within the transition, `animate()` specifies how long the transition will take. In this case, the state change from open to closed takes one second, expressed here as '1s'.

<code-example path="animations-guide/src/app/open-close.component.ts" title="src/app/open-close.component.ts" region="transition1">
</code-example>

We will also add a transition from `closed` to `open` state with a 0.5s duration.

<code-example path="animations-guide/src/app/open-close.component.ts" title="src/app/open-close.component.ts" region="transition2">
</code-example>

<div class="l-sub-section">

You can also define styles nested directly within the `transition()` function, with the following distinction between them:

* Use `state()` to define steady-state styles that are applied at the end of each transition.

* Use `transition()` to define intermediate styles which create the illusion of motion during the animation.

* When animations are disabled, `transition()` styles can be skipped, but `state()` styles cannot.
</div>

### Triggering the animation

We still need something to kick off the animation, so that it knows when to start. This is done through an animation trigger. The `trigger()` function collects the states and transitions, and gives the animation a name, so that you can attach it to the  triggering element in the HTML template.

The `trigger()` function describes the property name that should be watched for changes. When that change occurs, the trigger specifies the actions to apply. These actions can be transitions, or, as we will see later on, other animation functions as well.

For our example, we'll name the trigger `openClose`, and attach it to the `button` element. The trigger describes the open and closed states, and the timings for the two transitions. 

<figure>
 <img src="generated/images/guide/animations/triggering-the-animation-500.png" alt="triggering the animation">
</figure>

Here's the trigger function that describes and names the new trigger:

<!-- >does not show triggger in snippet<!-->
<code-example path="animations-guide/src/app/open-close.component.ts" title="src/app/open-close.component.ts" region="trigger">
</code-example>

<div class="l-sub-section">

Within each trigger() function call, an element can only be in one state at any given time. However, it is possible for multiple triggers to be active at once.
</div>

### Attaching animation to the HTML template

Animations are  defined in the metadata of the component that controls the HTML element to be animated. Put the code that defines your animations under the `animations:` property within the `@Component` decorator:

<code-example hideCopy language="typescript">
@Component({
 selector: 'open-close-component',
 animations: [
   trigger('openClose', [
     state('open', style({
       height: '200px',
       opacity: 1,
       backgroundColor: 'yellow'
     })),
</code-example>

When you have defined an animation trigger for a component, you can attach it to an element in that component's template by wrapping the trigger name in brackets and preceeding it with an @ symbol. Then, you can bind it to a template expression using standard Angular property binding syntax as shown below:

<code-example hideCopy language="typescript">
// this should match what `name` value is inside of the trigger(name)
[@openClose]] = "expression"
</code-example>
The animation is executed or triggered when the expression value changes to a new state.

#### HTML template file

<code-example path="animations-guide/src/app/open-close.component.html" title="src/app/open-close.component.html" region="trigger">
</code-example>

In the above code snippet, when the `isOpen` expression evaluates to a defined state: `open` or `closed`, it will notify the trigger `openClose` of a state change. It is then up to `openClose` code to handle the state change and kick off a state change animation.




### Code sample, simple transition

Here are the code files discussed on the transition example.

<code-tabs>

 <code-pane title="src/app/open-close.component.ts" path="animations-guide/src/app/open-close.component.ts">
 </code-pane>

 <code-pane title="src/app/open-close.component.html" path="animations-guide/src/app/open-close.component.html">
 </code-pane>

</code-tabs>

### Summary

The simplest possible animation transition is between two states, using `style()`, `state()`,  with `animate()` for the timing. The animation kicks off using the `trigger()` function, which is also how the animation is tied to the HTML template.

On the [Animation Basics Deep Dive](guide/animation-basics-deep-dive) page, we go into greater depth on callbacks, animation timing, some special states such as `wildcard *` and `void`, and show how these special states are used for elements entering and leaving a view.

## Reusable Animations

Angular animation provides [AnimationOptions](https://angular.io/api/animations/AnimationOptions) to configure or override options for each of the step-based animation methods.

These methods are:

* `sequence([...], { /* options */ })`
* `group([...], { /* options */ })`
* `trigger([...], { /* options */ })`
* `transition([...], { /* options */ })`
* `query([...], { /* options */ })`

<code-example hideCopy language="typescript">
transition('open => closed', [style({
       height: 200 px
   }, {
       opacity: "{{ opacity }}"
   }, {
       backgroundcolor: 'yelow'
   }),
   animate("{{ time }}"),
], {
   time: "1s",
   opacity: "1"
})
</code-example>

In the above code snippet, both time and opacity inputs will be replaced during runtime.

[AnimationOptions](https://angular.io/api/animations/AnimationOptions) allow you to reuse an animation across different components. Create a reusable animation in a seperate .ts file  using the [animation()](https://angular.io/api/animations/animation) method and export it as a const variable. You can then reuse it in any of your app components using the [useAnimation()](https://angular.io/api/animations/useAnimation) API.

<code-example hideCopy language="typescript">
// inside animation.ts

import {animation, style, animate} from "@angular/animations";
export var transAnimation = animation([
 style({ height: "{{ height }}",
 opacity: "{{ opacity }}", backgroundcolor: "{{backgroundcolor}}" }),
 animate("{{ time }}" ])
</code-example>

In the above code snippet, `transAnimation` is made reusable by declaring it as an export variable.  You can import the reusable `transAnimation` in your component class and reuse it using the `useAnimation()` method as shown below:

<code-example hideCopy language="typescript">
// inside of @Component.animations...

import {useAnimation, transition} from "@angular/animations";
import {transAnimation} from "./animations";
transition('open => closed', [
 useAnimation(transAnimation, {
   height: 0,
   opacity: 1,
   backgroundcolor:'red',
   time: '1s' }) ])
</code-example>


## Keyframes

In the previous section we saw a simple two-state transition. Now we’ll create an animation with multiple steps run in sequence using keyframes.

Angular’s `keyframe()` function is similar to keyframes in CSS. Keyframes allow several style changes within a single timing segment. For example, our button, instead of fading, could change color several times over a single 2-second timespan.

<figure>
 <img src="generated/images/guide/animations/keyframes-500.png" alt="keyframes">
</figure>

The code for the above might look like this:

<code-example path="animations-guide/src/app/status-slider.component.ts" title="src/app/status-slider.component.ts" region="keyframes">
</code-example>

### Offset

Keyframes include an _offset_ that defines at which point in the animation each style change occurs. Offsets are relative measures from zero to one, marking the beginning and end of the animation respectively.

Defining offsets for keyframes is optional. If you omit them, evenly spaced offsets are automatically assigned. For example, three keyframes without predefined offsets receive offsets 0, 0.5, and 1. Specifying an offset of 0.8 for the middle transition in the above example might look like this:

<figure>
 <img src="generated/images/guide/animations/keyframes-offset-500.png" alt="keyframes with offset">
</figure>

The code with offsets specified would be as follows:

<code-example path="animations-guide/src/app/status-slider.component.ts" title="src/app/status-slider.component.ts" region="keyframesWithOffsets">
</code-example>

You can combine keyframes together with duration, delay, and easing within a single animation.

### Keyframes with a pulsation

Here’s an example showing:

* The original open and closed states, with the original changes in height, color, and opacity, occurring over a timeframe of 1 second.

* A keyframes sequence inserted in the middle that causes the button to appear to pulsate irregularly over the course of that same 1-second timeframe.

<figure>
 <img src="generated/images/guide/animations/keyframes-pulsation-500.png" alt="keyframes with irregular pulsation">
</figure>

The code snippet for this animation might look like this:

<code-example path="animations-guide/src/app/open-close.component.fake.ts" title="src/app/open-close.component.ts" region="trigger">
</code-example>

<div class="l-sub-section">

The use of the wildcard state `*` under `transition()` in the above code snippet is described on the [Animation Basics Deep Dive](guide/animation-basics-deep-dive).

</div>

### Summary

The `keyframes()` function in Angular allows you to specify multiple interim styles within a single transition, with an optional offset to define at which point during the animation each style change occurs.

## Complex animation sequences

So far, we have been reviewing simple animations of single HTML elements. Angular also lets you animate coordinated sequences, such as an entire grid or list of elements as they enter and leave a page. You can choose to run multiple animations in parallel, or run discrete animations in sequential fashion, one following another.

Functions that control complex animation sequences are as follows:

* `query()` finds one or more inner HTML elements
* `stagger()` applies a cascading delay to animations for multiple elements
* `group()` runs multiple animation steps in parallel
* `sequence()` runs animation  steps one after another

### Grouping and staggering animations

First, we describe the grouping and choreographing of multiple animated HTML elements. The functions that allow this to happen are `query()` and `stagger()`.

<div class="l-sub-section">

The function known as `group()` is used to group animation steps, rather than animated elements.
</div>

The `query()` function targets specific HTML elements within a parent component and applies animations specifically to each element individually. Angular intelligently handles setup, tear-down, and cleanup as it coordinates the elements across the page.

### Multiple elements with query()

This [demo](http://animationsftw.in/#/) shows an example of a choreographed animation involving multiple elements in a grid. To see the portion that is relevant to this `query()` description, click **Advanced**. The Advanced tab contains three image galleries, each consisting of a grid with tiled photo images.

The page opens with an introductory sequence. The entire grid for Gallery One cascades in, with a slight delay from row to row from the bottom up. Within each row, the elements slide down and fade into place starting from right to left. To acheive this, the code uses both query() and stagger() methods.

#### Page entry query stagger example

The page entry animation code is as follows:

<code-example hideCopy language="typescript">

trigger('pageAnimations', [
 transition(':enter', [
   query ('.photo-record, .menu li, form', [
     style({
       opacity: 0,
       transform: 'translateY (-100px)' }),
     stagger (-30, [
       animate('500ms cubic-bezier(0.35, 0, 0.25, 1)',
         style({ opacity: 1, transform: 'none' })
       )
     ])
   ])
 ])
])

</code-example>

This animation does the following:

* Use `query()` to look for any element entering or leaving the page. The query specifies elements meeting certain CSS class criteria.

* For each of these elements, use `style()` to set the same initial style for the element – make it invisible and using transform to move it out of position so that it can slide down into place.

* Use `stagger()` to delay each animation by 30 milliseconds, starting at the bottom of the page.

* Animate each element in over 0.5 second using a custom-defined easing curve, simultaneously fading it in and un-transforming it at the same time.

In addition to the page animation that runs when you click **Advanced** from any other tab, there are additional animations when transitioning between Gallery Two, Gallery Three, and back to Gallery One again. You can review the code snippets embedded in the demo to see small differences in the `transition()` statements and animation parameters.

### Filter animation example

Let’s take a look at another animation on the [demo](http://animationsftw.in/#/)  page. In the upper left-hand corner of the **Advanced** page, enter some text into the “FILTER RESULTS” text box, such as “COOL” or “STYLE”.

The filter works real-time as you type. Elements (images) leave the page as the filter gets progressively stricter, when you type each new letter. The images successively re-enter the page, as you delete each letter in the filter box.

The component file contains 3 transitions:

<code-example hideCopy language="typescript">

trigger( 'filterAnimation', [
 transition( ':enter, [  ]),
 transition( ':increment', [
   query ( ':enter', [
     style( { opacity: 0, width: '0px' } ),
     stagger( 50, [
       animate  ('300ms ease-out', style( {
         opacity: 1, width: '*' } ) ),
     ]),
   ])
 ]),
 transition( ':decrement', [
   query ( ':leave', [
     stagger ( 50, [
       animate( '300ms ease-out', style( {
          opacity: 0, width: '0px' } ) ),
     ]),
   ])
 ]),
])

</code-example> 

<div class="l-sub-section">

NOTE: The use of the special aliases `:enter`, `:leave`, `:increment`, and `:decrement` are described on the [Animation Basics Deep Dive](guide/animation-basics-deep-dive).

</div>


The animation does the following:

* Ignore any animations that are performed when the user first opens or navigates to this page. Since the filter narrows what is already there, it assumes that any HTML elements to be animated already exist in the DOM.

* Perform a filter match for matches.

For each match:

* First, hide the element by making it completely transparent and infinitely narrow, by setting its opacity and width to 0.

* Animate in the element over 300 milliseconds. During the animation, the element assumes its default width and opacity.

* If there are multiple matching elements, stagger each element in starting at the top of the page, with a 50-millisecond delay between each element.

### Sequential vs. parallel animations

Complex animations can have many things happening at once. But what if you want to create an animation involving not just one, but several choreographies happening one after the other? Earlier we used `group()` to run multiple animations all at the same time, in parallel.

A second function called `sequence()` lets you run those same animations one after the other. Within `sequence()`, the animation steps consist of either `style()` or `animate()` function calls.

* Use `style()` to apply the provided styling data immediately.

* Use `animate()` to apply styling data over a given time interval.

### Summary

Angular functions for choreographing multiple elements start with `query()` to find inner elements, for example gathering all images within a `<div>`. The remaining functions, `stagger()`, `group()`, and `sequence()`, apply cascades or allow you to control how multiple animation steps are applied.

## Animation DSL

Angular provides a domain-specific language (DSL) for animations. See @angular/animations module in the [API reference](api) for a listing and syntax of core functions and related data structures.


<table>

<tr>
  <th style="vertical-align: top">
    Function name
  </th>

  <th style="vertical-align: top">
    What it does
  </th>
</tr>

<tr>
  <td><code>trigger()</code></td>
  <td>Kicks off the animation and serves as a container for all other animation function calls. HTML template binds to <code>triggerName</code>. Use the first argument to declare a unique trigger name. Uses array syntax.</td>
</tr>

<tr>
  <td><code>style()</code></td>
  <td>Defines one or more CSS styles to use in animations. Controls visual appearance of HTML elements during animations. Uses object syntax.</td>
</tr>

<tr>
  <td><code>state()</code></td>
  <td>Creates a named set of CSS styles which should be applied on successful transition to a given state. The state can then be referenced by name within other animation functions.</td>
</tr>

<tr>
  <td><code>animate()</code></td>
  <td>Specifies timing information for a transition. Optional values for delay and easing. Can contain <code>style()</code> calls within.</td>
</tr>

<tr>
  <td><code>transition()</code></td>
  <td>Defines animation sequence between 2 named states. Uses array syntax.</td>
</tr>

<tr>
  <td><code>keyframes()</code></td>
  <td>Allows a sequential change between styles within a specified time interval. Use within <code>animate()</code>. Can include multiple <code>style()</code> calls within each <code>keyframe()</code>. Uses array syntax.</td>
</tr>

<tr>
  <td><code>group()</code></td>
  <td>Specifies a group of animation steps (<em>inner animations</em>) to be run in parallel. Animation continues only after all inner animation steps have completed. Used within <code>sequence()</code> or <code>transition()</code></td>
</tr>

<tr>
  <td><code>query()</code></td>
  <td>Use to find one or more inner HTML elements within the current element. </td>
</tr>

<tr>
  <td><code>sequence()</code></td>
  <td>Specifies a list of animation steps that are run sequentially, one by one.</td>
</tr>

<tr>
  <td><code>stagger()</code></td>
  <td>Staggers the starting time for animations for multiple elements.</td>
</tr>

<tr>
  <td><code>animation()</code></td>
  <td>Produces a re-usable animation that can be invoked from elsewhere. Used together with <code>useAnimation()</code>.</td>
</tr>

<tr>
  <td><code>useAnimation()</code></td>
  <td>Activates a reusable animation. Used together with <code>animation()</code>.</td>
</tr>

<tr>
  <td><code>animateChild()</code></td>
  <td>Allows animations on child components to be run within the same timeframe as the parent.</td>
</tr>

</table>
