# Providers

#### Prerequisites:

* A basic understanding of [Bootstrapping](guide/bootstrapping).
* Familiarity with [Frequently Used Modules](guide/frequent-ngmodules).

<hr>

## Create a service
You can provide services to your app by using the providers array in an NgModule.
Consider the default app generated by the CLI. In order to add a user service to it,
you can generate one by entering the following command in the terminal window:

```
ng generate service User
```

This creates a service called `UserService` and returns a message telling you
that you need to provide it. Update `app.module.ts` by importing it with your
other import statements at the top of the file and adding it to the providers array:

```javascript
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { HttpModule } from '@angular/http';

import { AppComponent } from './app.component';

/* Import your service here. */
import { UserService } from './user.service;

@NgModule({
 declarations: [
   AppComponent
 ],
 imports: [
   BrowserModule,
   FormsModule,
   HttpModule
 ],
 providers: [UserService], /* List your services here. */
 bootstrap: [AppComponent]
})
export class AppModule { }
```

## Provider scope

When you add a service provider to the providers array of the root module, it’s available throughout the app. Additionally, when you import a module that has providers, those providers are also available to all the classes in the app as long they have the lookup token. For example, if you import the `HttpModule` into your `AppModule`, its providers are then available to the entire app and you can make HTTP requests from anywhere in your app.


## Limiting provider scope by lazy loading modules

In the basic CLI generated app, modules are eagerly loaded which means that they are all loaded when the app launches. Angular uses an injector system to make things available between modules. In an eagerly loaded app, the root application injector makes all of the providers in all of the modules available throughout the app.

This behavior necessarily changes when you use lazy loading. Lazy loading is when you load modules only when you need them. They aren’t loaded right away like in an eagerly loaded app. This means that any services listed in their provider arrays aren’t available because the root injector doesn’t even know about these modules.

When the Angular router lazy-loads a module, it creates a new execution context. This new context has its own injector which is a child of the root application injector. Imagine a tree of injectors; there is a single root injector and then a child injector for each lazy loaded module. The router adds all of the providers from the root injector to the child injector. When the router creates a component within the lazy-loaded context, Angular prefers service instances created from these providers to the service instances of the application root injector.

Any component created within a lazy loaded module’s context, such as by router navigation, gets the local instance of the service, not the instance in the root application injector. Components in external modules continue to receive the instance created for the application root.

Though you can provide services by lazy loading modules, not all services can be lazy loaded. There are some modules that will only work in the root module, such as the Router. The Router works with the global location object in the browser.

<!--Is there anything else that should go here? We say "there are some".-->



## Limiting provider scope with components

Another way to limit provider scope is by adding the service you want to limit to the component’s provider array. This method is helpful for when you want to eagerly load a module that needs a service all to itself. Providing a service in the component limits the service only to that component and other components in the same module can’t access it.

To make the component’s provided services available to other components in the same module, create a parent component that acts as a root for all of the module’s components. Then, add the service to the parent’s provider’s array. To use the child components, embed them in the parent component’s template. 

<!--KW--What is Importing a service’s type?
Insert code snippet making sure to include importing the service’s type-->


## Providing services in modules vs. components

Though you can provide services through components if necessary, it’s usually better to provide them in modules because lazy loaded modules and their components can inject services from the root module, but not the `AppComponent`. Generally, provide services the whole app needs in the root module and scope services by providing them in lazy loaded modules.

The router works at the root level so if you put providers in a component, even `AppComponent`, lazy loaded modules, which rely on the router, can’t see them. 

Register a provider with a component when you must limit a service instance to a component and its component tree, that is, its child components. For example, a customer editing component, `UserEditorComponent`, that needs a private copy of a caching `UserService` should register the `UserService` with the `UserEditorComponent`. Then each new instance of the `UserEditorComponent` gets its own cached service instance.



## The app-wide singleton service

<!--KW--This wording needs help. Is this correct?-->
You can provide a singleton service, or a service that Angular instantiates one time, through a module especially 
for providing that service and any other services and components that need to be singletons. The key to setting up 
a module for this purpose is that you import it only once in the root `AppModule`. This way, Angular 
registers it exactly once, in the app root injector, when the application starts.

Consider the following `CoreModule` example (you could name it anything):

<!--KW--Should this example include a component, too?-->
```typescript
import { NgModule }            from '@angular/core';
import { CommonModule }        from '@angular/common';

import { NewItemService }  from './newitem.service';
 
@NgModule({
  imports:      [ CommonModule ],
  declarations: [ ],
  exports:      [ ],
  providers:    [ NewItemService ]
})
export class CoreModule { }
```

`CoreModule` provides the `NewItemService`. Angular registers that provider with the app root injector,
making a singleton instance of the `UserService` available to any component that needs it,
whether that component is eagerly or lazily loaded.

The root `AppModule` could register the `NewItemService` directly, but as the app 
grows, it could have other services, and components like spinners, modals, etc. To 
keep your app organized, consider using a module to organize and provide them. This 
technique simplifies the root `AppModule` in its capacity as orchestrator of 
the application as a whole.

Now you can inject such services into components as needed&mdash;just make sure to use 
JavaScript `import` statements. You don't need to, and shouldn't, define or recreate the 
services in any other module. See [JS Modules vs. NgModules](ngmodule-vs-jsmodule) for 
more information on how to differentiate between the two.

As a general rule, import modules with providers _exactly once_, preferably in the application's _root module_.
That's also usually the best place to configure, wrap, and override them.


### Configure core services with `CoreModule.forRoot()`

A module that adds providers to the application can offer a facility for configuring those providers as well.

By convention, the `forRoot()` static method both provides and configures services at the same time.
It takes a service configuration object and returns a
[ModuleWithProviders](api/core/ModuleWithProviders), which is
a simple object with the following properties:

* `ngModule`: the `CoreModule` class.
* `providers`: the configured providers.

The root `AppModule` imports the `CoreModule` and adds the `providers` to the `AppModule` providers.
More precisely, Angular accumulates all imported providers before appending the items listed in `@NgModule.providers`. This sequence ensures that whatever you add explicitly to the `AppModule` providers takes precedence over the providers of imported modules.

You can add a `CoreModule.forRoot()` method that configures the core `NewItemService`.










## Unedited from here down
<!--
KW--The following is from the current NgModules doc. Do we want to cover this topic on this particular page?-->
You've extended the core `UserService` with an optional, injected `UserServiceConfig`.
If a `UserServiceConfig` exists, the `UserService` sets the user name from that config.

<code-example path="ngmodule/src/app/core/user.service.ts" region="ctor" title="src/app/core/user.service.ts (constructor)" linenums="false">

</code-example>



Here's `CoreModule.forRoot` that takes a `UserServiceConfig` object:

<code-example path="ngmodule/src/app/core/core.module.ts" region="for-root" title="src/app/core/core.module.ts (forRoot)" linenums="false">

</code-example>



Lastly, call it within the `imports` list of the `AppModule`.

<code-example path="ngmodule/src/app/app.module.ts" region="import-for-root" title="src/app//app.module.ts (imports)" linenums="false">

</code-example>



The app displays "Miss Marple" as the user instead of the default "Sherlock Holmes".


<div class="alert is-important">


<!--KW -- Why can it produce a runtime error?-->
Call `forRoot` only in the root application module, `AppModule`.
Calling it in any other module, particularly in a lazy-loaded module,
is contrary to the intent and can produce a runtime error.

<!--KW --Import as in a JavaScript import? Or the imports array?-->
Remember to _import_ the result; don't add it to any other `@NgModule` list.

</div>

<hr/>

## Prevent reimport of the _CoreModule_
<!--KW--I tried the recommendation for seeing it break in the FAQ and didn't see how it was breaking. It seemed like it didn't break.-->
Only the root `AppModule` should import the `CoreModule`.
[Bad things happen](guide/ngmodule-faq#q-why-bad) if a lazy-loaded module imports it.

You could hope that no developer makes that mistake.
Or you can guard against it and fail fast by adding the following `CoreModule` constructor.

<code-example path="ngmodule/src/app/core/core.module.ts" region="ctor" title="src/app/core/core.module.ts" linenums="false">

</code-example>


The constructor tells Angular to inject the `CoreModule` into itself.
That seems dangerously circular.

The injection would be circular if Angular looked for `CoreModule` in the _current_ injector.
The `@SkipSelf` decorator means "look for `CoreModule` in an ancestor injector, above me in the injector hierarchy."

If the constructor executes as intended in the `AppModule`,
there is no ancestor injector that could provide an instance of `CoreModule`.
The injector should give up.

By default, the injector throws an error when it can't find a requested provider.
The `@Optional` decorator means not finding the service is OK.
The injector returns `null`, the `parentModule` parameter is null,
and the constructor concludes uneventfully.

It's a different story if you improperly import `CoreModule` into a lazy-loaded module such as `HeroModule` (try it).

Angular creates a lazy-loaded module with its own injector, a _child_ of the root injector.
`@SkipSelf` causes Angular to look for a `CoreModule` in the parent injector, which this time is the root injector.
Of course it finds the instance imported by the root `AppModule`.
Now `parentModule` exists and the constructor throws the error.

<hr>

## More on NgModules

You may also be interested in:
* [Lazy Loading Modules](guide/lazy-loading-ngmodules.md).
* [NgModule FAQ](guide/ngmodule-faq).
