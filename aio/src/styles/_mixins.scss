/************************************

             Media queries

 To use these, put this snippet in the appropriate selector:

     @include bp(tiny) {
         background-color: purple;
     }

     Replace "tiny" with "medium" or "big" as necessary.
      @include bp-starting-at(tiny) {
        background-color: purple;
      }

  or

      @include bp-up-to(tiny) {
        background-color: purple;
      }

  Replace "tiny" one of (xxsmall, xsmall, teeny, tiny, small, medium, big) as necessary.

  bp-starting-at(<size>) => creates a Media Query including <size> and any breakpoint bigger than <size>
  bp-up-to(<size>) => creates a Media Query including <size> and any breakpoint smaller than <size>

*************************************/

@mixin bp-starting-at($point, $mediatype:null) {
  // Makes no sense to call this mixin with 'xxsmall' as parameter
  // $breakpoint-xxsmall-min: $breakpoint-xxsmall;
  $breakpoint-xsmall-min: $breakpoint-xsmall;
  $breakpoint-teeny-min:  $breakpoint-teeny;
  $breakpoint-tiny-min:   $breakpoint-tiny;
  $breakpoint-small-min:  $breakpoint-small;
  $breakpoint-medium-min: $breakpoint-medium;
  $breakpoint-big-min:    $breakpoint-big;

  $map: (
    // xxsmall: $breakpoint-xxsmall-min,
    xsmall: $breakpoint-xsmall-min,
    teeny: $breakpoint-teeny-min,
    tiny: $breakpoint-tiny-min,
    small: $breakpoint-small-min,
    medium: $breakpoint-medium-min,
    big: $breakpoint-big-min,
  );

  @if not map-has-key($map, $point) {
    @error "Invalid breakpoint key `#{$point}` for mixin `bp-starting-at`"
  }

  $breakpoint-size: "(min-width: #{map-get($map, $point)})";

  @if $mediatype {
    $breakpoint-size: "#{$mediatype} and #{$breakpoint-size}";
  }

  @media #{$breakpoint-size} { @content; }
}

@mixin bp-up-to($point, $mediatype:null) {
  // Makes no sense to call this mixin with 'big' as parameter
  $breakpoint-xxsmall-max: $breakpoint-xsmall - 1px;
  $breakpoint-xsmall-max:  $breakpoint-teeny  - 1px;
  $breakpoint-teeny-max:   $breakpoint-tiny   - 1px;
  $breakpoint-tiny-max:    $breakpoint-small  - 1px;
  $breakpoint-small-max:   $breakpoint-medium - 1px;
  $breakpoint-medium-max:  $breakpoint-big    - 1px;
  // $breakpoint-big-max:  infinite;

  $map: (
    xxsmall: $breakpoint-xxsmall-max,
    xsmall: $breakpoint-xsmall-max,
    teeny: $breakpoint-teeny-max,
    tiny: $breakpoint-tiny-max,
    small: $breakpoint-small-max,
    medium: $breakpoint-medium-max,
    // big: $breakpoint-big-max,
  );

  @if not map-has-key($map, $point) {
    @error "Invalid breakpoint key `#{$point}` for mixin `bp-up-to`"
  }

  $breakpoint-size: "(max-width: #{map-get($map, $point)})";

  @if $mediatype {
    $breakpoint-size: "#{$mediatype} and #{$breakpoint-size}";
  }

  @media #{$breakpoint-size} { @content; }
}

// @mixin bp-handheld {
//   @media handheld and (max-width: 480px),
//          screen and (max-width: 480px),
//          screen and (max-width: 900px) {
//            @content;
//          }
// }

@mixin bp-handheld($handheld: default, $screen1: default, $screen2: default) {

  @if $handheld == default {
    $handheld: #{$breakpoint-teeny - 1px};
  }
  @if $screen1 == default {
    $screen1: #{$breakpoint-teeny - 1px};
  }
  @if $screen2 == default {
    $screen2: 900px;
  }

  $val: ();

  @if $handheld {
    $val: append($val, "handheld and (max-width: #{$handheld})", comma);
  }
  @if $screen1 {
    $val: append($val, "screen and (max-width: #{$screen1})", comma);
  }
  @if $screen2 {
    $val: append($val, "screen and (max-width: #{$screen2})", comma);
  }

  @media #{$val} { @content; }
}

@mixin bp($point) {

  $bp-xsmall: "(min-width: 320px)";
  $bp-teeny: "(min-width: 480px)";
  $bp-tiny: "(min-width: 600px)";
  $bp-small: "(min-width: 650px)";
  $bp-medium: "(min-width: 800px)";
  $bp-big: "(min-width: 1000px)";

  @if $point == big {
    @media #{$bp-big} { @content; }
  }
  @else if $point == medium {
    @media #{$bp-medium} { @content; }
  }
  @else if $point == small {
    @media #{$bp-small}  { @content; }
  }
  @else if $point == tiny {
    @media #{$bp-tiny}  { @content; }
  }
  @else if $point == teeny {
    @media #{$bp-teeny}  { @content; }
  }
  @else if $point == xsmall {
    @media #{$bp-xsmall}  { @content; }
  }
}

// REM Font Adjustments
@mixin font-size($sizeValue) {
  font-size: ($sizeValue) + px;
  font-size: ($sizeValue / 10) + rem;
}

@mixin letter-spacing($spacingValue) {
  letter-spacing: ($spacingValue) + px;
  letter-spacing: ($spacingValue / 10) + rem;
}

@mixin line-height($heightValue) {
  line-height: ($heightValue) + px;
  line-height: ($heightValue / 10) + rem;
}

// PLACEHOLDER
// NOTE: Vendor-prefixed selectors must be on separate blocks, because one invalid/unknown
//       selector will invalidate the whole block.
@mixin placeholder {
  &:-ms-input-placeholder      { @content; }  // IE
  &::-ms-input-placeholder     { @content; }  // Edge
  &::-webkit-input-placeholder { @content; }  // QQ Browser
  &::placeholder               { @content; }  // Chrome/Firefox/Safari
}

@mixin rotate($degrees) {
  -moz-transform: rotate($degrees);
  -webkit-transform: rotate($degrees);
  -o-transform: rotate($degrees);
  -ms-transform: rotate($degrees);
  transform: rotate($degrees);
  transition: transform 150ms;
  transition-timing-function: ease-in-out;
}

@mixin codeblock($bgcolor) {
    background-color: $bgcolor;
    border-radius: 5px;
    padding: 20px;
    margin: 0 auto; // was 24
    border: 0.5px solid $lightgray;
}

// INFO CARD SKELETON
@mixin card($height, $width) {
  height: $height;
  width: $width;
  background-color: $white;
  border-radius: 4px;
  box-shadow: 0 2px 2px rgba($black, 0.24), 0 0 2px rgba($black, 0.12);
  box-sizing: border-box;
  transition: box-shadow .5s;

  &:hover {
    box-shadow: 0 8px 8px rgba($black, 0.24), 0 0 8px rgba($black, 0.12);
    text-decoration: none;
  }
}
