/**
 * Transform template html and css into executable code.
 * Intended to be used in a build step.
 */

import * as compiler from 'angular2/src/compiler/compiler';
// TODO(alexeagle): expose these as well?
import {RuntimeMetadataResolver} from 'angular2/src/compiler/runtime_metadata';
import {HtmlParser} from 'angular2/src/compiler/html_parser';
import {DirectiveNormalizer} from "angular2/src/compiler/directive_normalizer";
import {Lexer} from "angular2/src/compiler/expression_parser/lexer";
import {Parser} from "angular2/src/compiler/expression_parser/parser";
import {TemplateParser} from 'angular2/src/compiler/template_parser';
import {DomElementSchemaRegistry} from 'angular2/src/compiler/schema/dom_element_schema_registry';
import {StyleCompiler} from 'angular2/src/compiler/style_compiler';
import {ViewCompiler} from "angular2/src/compiler/view_compiler/view_compiler";
import {TypeScriptEmitter} from "angular2/src/compiler/output/ts_emitter";

var mkdirp = require('mkdirp');

import * as fs from 'fs';
import * as path from 'path';
import {RouterLinkTransform} from "angular2/src/router/directives/router_link_transform";

const PREAMBLE = '// This code is generated by the Angular 2 template compiler. Do not edit.\n\n';

class OfflineLinker {
  constructor(private options: OfflineLinkerOptions, private resolver: RuntimeMetadataResolver,
              private compiler: compiler.OfflineCompiler) {}

  generateSource(metadatas: compiler.CompileDirectiveMetadata[]) {
    let normalize = (metadata) => {
      let directiveType = metadata.type.runtime;
      let directives = this.resolver.getViewDirectivesMetadata(directiveType);
      let pipes = this.resolver.getViewPipesMetadata(directiveType);
      // directives[0].type.moduleUrl = 'not null'; // same path the component got it from
      // pipes[0].type.moduleUrl = 'not null also';
      // also walk:
      // providers?: Array<CompileProviderMetadata | CompileTypeMetadata | any[]>,
      // viewProviders?: Array<CompileProviderMetadata | CompileTypeMetadata | any[]>,
      return new compiler.NormalizedComponentWithViewDirectives(metadata, directives, pipes);
    };

    return this.compiler.compileTemplates(metadatas.map(normalize));
  };

  write(source: string, filename: string) {
    fs.writeFileSync(filename, PREAMBLE + source);
    console.log(`[OfflineCompiler] Wrote ${filename}`);
  }

  main() {
    let allTemplates = new Map<string, string>();
    let linkerImports = `import {reflector, ReflectionInfo} from 'angular2/core';\n`;
    let linkerContent = `
let createReflectionInfo = (componentType: any, hostViewFactory: any) => {
  var annotations = reflector.annotations(componentType) || [];
  return new ReflectionInfo(annotations.concat([hostViewFactory]));
}
export function initReflector() {\n`;

    let promises = this.options.componentSources.map((componentSource) => {
      // FIXME: patch the module loader to find the path of every exported symbol
      let template = require(componentSource);
      var outfile = path.relative(process.env.NODE_PATH || process.cwd(), require.resolve(componentSource));
      let componentMetadatas: Promise<compiler.CompileDirectiveMetadata>[] = [];
      for (var exported in template) {
        let symbol = template[exported];
        let directive: compiler.CompileDirectiveMetadata;
        try {
          directive = this.resolver.getDirectiveMetadata(symbol);
        } catch (e) {
          // TODO: directive resolver throws on non-directive symbols
          // for now, just catch those and continue
          continue;
        }
        if (!directive.isComponent) {
          continue;
        }
        componentMetadatas.push(this.compiler.normalizeDirectiveMetadata(directive).then((m) => {
          m.type.moduleUrl = 'asset:tmp/lib/' + path.basename(outfile).replace(/\.js$/, '');
          return m;
        }));
      }

      var templateFile = path.join(this.options.outDir, outfile.replace(/\.js$/, '.template.ts'));

      mkdirp.sync(path.dirname(templateFile));
      return Promise.all(componentMetadatas)
          .then((metadatas: compiler.CompileDirectiveMetadata[]) => {
            this.write(this.generateSource(metadatas).source, templateFile);
            metadatas.forEach((metadata: compiler.CompileDirectiveMetadata) => {
              let symbol = `hostViewFactory_${metadata.type.name}`;
              linkerImports += `import {${symbol}} from './${outfile.replace(/\.js$/, '.template')}';\n`;
              linkerImports += `import {${metadata.type.name}} from './${componentSource}';\n`;
              //linkerImports += `import {${symbol}} from '.template';\n`;
              linkerContent += `  reflector.registerType(${metadata.type.name}, createReflectionInfo(${metadata.type.name}, ${symbol}));\n`;
            });
          })
          .catch((e) => { console.log('ERROR', e, e.stack); });
    });

    Promise.all(promises).then(() => {
      linkerContent += `}\n`;
      this.write(linkerImports + linkerContent, path.join(this.options.outDir, 'templates.ts'));
    });


  }

  // TODO: use DI to create this object graph??
  static create(options: OfflineLinkerOptions): OfflineLinker {
    let xhr: compiler.XHR = null;
    let urlResolver: compiler.UrlResolver = null;
    let htmlParser = new HtmlParser();
    let normalizer = new DirectiveNormalizer(xhr, urlResolver, htmlParser);
    let parser = new Parser(new Lexer());

    let tmplParser = new TemplateParser(new Parser(new Lexer()), new DomElementSchemaRegistry(),
                                        htmlParser, [new RouterLinkTransform(parser)]);

    options.compilerConfig =
        options.compilerConfig || new compiler.CompilerConfig(true, true, false);

    let offlineCompiler = new compiler.OfflineCompiler(normalizer, tmplParser,
      new StyleCompiler(urlResolver), new ViewCompiler(new compiler.CompilerConfig(true, true, true)),
      new TypeScriptEmitter());

    return new OfflineLinker(
        options, new RuntimeMetadataResolver(new compiler.DirectiveResolver(), new compiler.PipeResolver(),
                                             new compiler.ViewResolver(), null, null), offlineCompiler);
  }
}

export interface OfflineLinkerOptions {
  componentSources: string[];
  outDir: string;
  compilerConfig?: compiler.CompilerConfig;
}

export function main(options: OfflineLinkerOptions): void {
  OfflineLinker.create(options).main();
}
