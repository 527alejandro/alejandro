/**
 * Transform template html and css into executable code.
 * Intended to be used in a build step.
 */
var mkdirp = require('mkdirp');

import * as fs from 'fs';
import * as path from 'path';
import {ChangeDetectionCompiler} from '../compiler/change_detector_compiler';
import {CompileDirectiveMetadata} from '../compiler/directive_metadata';
import {HtmlParser} from '../compiler/html_parser';
import {ProtoViewCompiler} from '../compiler/proto_view_compiler';
import {RuntimeMetadataResolver} from '../compiler/runtime_metadata';
import {SourceModule} from '../compiler/source_module';
import {StyleCompiler} from '../compiler/style_compiler';
import {
  TemplateCompiler,
  NormalizedComponentWithViewDirectives
} from '../compiler/template_compiler';
import {TemplateNormalizer} from '../compiler/template_normalizer';
import {TemplateParser} from '../compiler/template_parser';
import {DomElementSchemaRegistry} from '../compiler/schema/dom_element_schema_registry';
import {UrlResolver} from '../compiler/url_resolver';
import {ViewCompiler} from '../compiler/view_compiler';
import {XHR} from '../compiler/xhr';
import {ChangeDetectorGenConfig} from '../core/change_detection/interfaces';
import {Lexer} from '../core/change_detection/parser/lexer';
import {Parser} from '../core/change_detection/parser/parser';
import {DirectiveResolver} from '../core/linker/directive_resolver';
import {PipeResolver} from '../core/linker/pipe_resolver';
import {ViewResolver} from '../core/linker/view_resolver';
import {RouterLinkTransform} from '../router/router_link_transform';

const PREAMBLE = '// This code is generated by the Angular 2 template compiler. Do not edit.\n\n';

class OfflineCompiler {
  constructor(private options: OfflineCompilerOptions, private resolver: RuntimeMetadataResolver,
              private compiler: TemplateCompiler) {}

  generateSource(metadatas: CompileDirectiveMetadata[]) {
    let normalize = (metadata) => {
      let directiveType = metadata.type.runtime;
      let directives = this.resolver.getViewDirectivesMetadata(directiveType);
      let pipes = this.resolver.getViewPipesMetadata(directiveType);
      // directives[0].type.moduleUrl = 'not null'; // same path the component got it from
      // pipes[0].type.moduleUrl = 'not null also';
      // also walk:
      // providers?: Array<CompileProviderMetadata | CompileTypeMetadata | any[]>,
      // viewProviders?: Array<CompileProviderMetadata | CompileTypeMetadata | any[]>,
      return new NormalizedComponentWithViewDirectives(metadata, directives, pipes);
    };

    return this.compiler.compileTemplatesCodeGen(metadatas.map(normalize));
  };

  writeTemplateCodegen(source: SourceModule, filename: string) {
    let importStatements = source.getSourceWithImports().imports.map(
        ([path, importName]: string[]) =>
            `var ${importName} = require('${path.replace(/^package:/, '')}');`);
    fs.writeFileSync(filename,
                     PREAMBLE + importStatements.join('\n') + source.getSourceWithImports().source);
    console.log(`[OfflineCompiler] Wrote ${filename}`);
  }

  patchComponentAnnotations(componentSource: string, metadatas: CompileDirectiveMetadata[]) {
    // FIXME: preserve the sourcemap as the last line
    // FIXME: what about if the file was already patched because user codes in ES*?
    let emit: string = '\n\n// Generated code to pre-load the compiled template. Do not edit.\n';
    metadatas.forEach((metadata: CompileDirectiveMetadata) => {
      emit += `
var annotations = Reflect.getOwnMetadata('annotations', ${metadata.type.name}) || [];
annotations.push(require('./${path.basename(componentSource)}.template').hostViewFactory_${metadata.type.name});
Reflect.defineMetadata('annotations', annotations, ${metadata.type.name});
`;
    });
    var filename = require.resolve(componentSource);
    fs.appendFile(filename, emit);
    console.log(`[OfflineCompiler] Patched ${filename}`);
  }

  main() {
    this.options.componentSources.forEach((componentSource) => {
      // FIXME: patch the module loader to find the path of every exported symbol
      let template = require(componentSource);
      var outfile = path.relative(process.cwd(), require.resolve(componentSource));
      let componentMetadatas: Promise<CompileDirectiveMetadata>[] = [];
      for (var exported in template) {
        let symbol = template[exported];
        let directive: CompileDirectiveMetadata;
        try {
          directive = this.resolver.getDirectiveMetadata(symbol);
        } catch (e) {
          // TODO: directive resolver throws on non-directive symbols
          // for now, just catch those and continue
          continue;
        }
        if (!directive.isComponent) {
          continue;
        }
        componentMetadatas.push(this.compiler.normalizeDirectiveMetadata(directive).then((m) => {
          m.type.moduleUrl = './' + path.basename(outfile);
          return m;
        }));
      }

      var templateFile = path.join(this.options.outDir, outfile.replace(/\.js$/, '.template.js'));
      mkdirp.sync(path.dirname(templateFile));
      Promise.all(componentMetadatas)
          .then((metadatas: CompileDirectiveMetadata[]) => {
            this.writeTemplateCodegen(this.generateSource(metadatas), templateFile);
            this.patchComponentAnnotations(componentSource, metadatas);
          })
          .catch((e) => { console.log('ERROR', e, e.stack); });
    });
  }

  // TODO: use DI to create this object graph
  static create(options: OfflineCompilerOptions): OfflineCompiler {
    let xhr: XHR = null;
    let urlResolver: UrlResolver = null;
    let htmlParser = new HtmlParser();
    let normalizer = new TemplateNormalizer(xhr, urlResolver, htmlParser);
    let styleCmp = new StyleCompiler(xhr, urlResolver);
    let parser = new Parser(new Lexer());

    let tmplParser = new TemplateParser(new Parser(new Lexer()), new DomElementSchemaRegistry(),
                                        htmlParser, [new RouterLinkTransform(parser)]);

    options.changeDetectorCfg =
        options.changeDetectorCfg || new ChangeDetectorGenConfig(true, true, false);
    let changeDetectionCompiler = new ChangeDetectionCompiler(options.changeDetectorCfg);

    return new OfflineCompiler(
        options, new RuntimeMetadataResolver(new DirectiveResolver(), new PipeResolver(),
                                             new ViewResolver(), null, null),
        new TemplateCompiler(null /* RuntimeMetadataResolver */, normalizer, tmplParser, styleCmp,
                             changeDetectionCompiler, new ProtoViewCompiler(), new ViewCompiler(),
                             null /* ResolvedMetadataCache */, options.changeDetectorCfg));
  }
}

export interface OfflineCompilerOptions {
  componentSources: string[];
  outDir: string;
  changeDetectorCfg?: ChangeDetectorGenConfig;
}

export function compile(options: OfflineCompilerOptions): void {
  OfflineCompiler.create(options).main();
}
